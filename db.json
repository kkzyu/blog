{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-vivia/source/avatar.jpg","path":"avatar.jpg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-dark-128.png","path":"images/favicon-dark-128.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-dark-180.png","path":"images/favicon-dark-180.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-dark-192.png","path":"images/favicon-dark-192.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-dark-32.png","path":"images/favicon-dark-32.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-light-128.png","path":"images/favicon-light-128.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-light-180.png","path":"images/favicon-light-180.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-light-192.png","path":"images/favicon-light-192.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/images/tile.png","path":"images/tile.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-light-32.png","path":"images/favicon-light-32.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/js/color.global.min.js","path":"js/color.global.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/js/jquery-3.4.1.min.js","path":"js/jquery-3.4.1.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/js/light-dark-switch.js","path":"js/light-dark-switch.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/js/load-settings.js","path":"js/load-settings.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/Roboto-Bold.ttf","path":"css/fonts/Roboto-Bold.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/Roboto-Medium.ttf","path":"css/fonts/Roboto-Medium.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/Roboto-Regular.ttf","path":"css/fonts/Roboto-Regular.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"source/cancerAI-1-4.png","path":"cancerAI-1-4.png","modified":1,"renderable":0},{"_id":"source/cancerAI-1-3.png","path":"cancerAI-1-3.png","modified":1,"renderable":0},{"_id":"source/cancerAI-1-1.png","path":"cancerAI-1-1.png","modified":1,"renderable":0},{"_id":"source/cancerAI-1-2.png","path":"cancerAI-1-2.png","modified":1,"renderable":0},{"_id":"source/cancerAI-2-1.png","path":"cancerAI-2-1.png","modified":1,"renderable":0},{"_id":"source/cancerAI-2-2.png","path":"cancerAI-2-2.png","modified":1,"renderable":0},{"_id":"source/day1_react_learning-1.png","path":"day1_react_learning-1.png","modified":1,"renderable":0},{"_id":"source/day1_react_learning-2.png","path":"day1_react_learning-2.png","modified":1,"renderable":0},{"_id":"source/headpic.jpg","path":"headpic.jpg","modified":1,"renderable":0},{"_id":"source/day2-react-learning-1.png","path":"day2-react-learning-1.png","modified":1,"renderable":0},{"_id":"source/week1-研发周报-作业管理详情页开发-1.png","path":"week1-研发周报-作业管理详情页开发-1.png","modified":1,"renderable":0},{"_id":"source/musicshare.jpg","path":"musicshare.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/cancerAI-2-2.png","hash":"efa5ea0d8e6377df29fd6c0217ad125ad22cd759","modified":1752326129145},{"_id":"source/day1_react_learning-2.png","hash":"2893dd3e1ef55c2bd2ba4010aaf64c16ef3d161f","modified":1752038466699},{"_id":"source/_posts/cancerAI-2.md","hash":"5f33c8ab574f8ff54d99b4c60eeb309c74983993","modified":1752380165143},{"_id":"source/_posts/cancerAI_1.md","hash":"542b2d99f6ff9fa73b936dddc6ac37d571d220ee","modified":1752326445703},{"_id":"source/about/index.md","hash":"81b33337835322f7f2529608649942209b4211c6","modified":1751939069143},{"_id":"source/_posts/day1-react-learning.md","hash":"f0c6cbbb30ed9da800b5d0f1cd5a431ab9b75d75","modified":1752322005345},{"_id":"source/_posts/day2-react-learning.md","hash":"bb503826b7a9967b22eb92907e71634f7a295c52","modified":1752322017636},{"_id":"source/_posts/pinia重构.md","hash":"eff92689d6119ef6d0df94c2f5de1a1baa1b2f58","modified":1751939069143},{"_id":"source/_posts/hello-world.md","hash":"3d7c1589c785986c6749169796b789b1e2790f59","modified":1752031894957},{"_id":"source/_posts/github-actions.md","hash":"d5076e1f8cdc8bbf691acaca1ef7b92149b4b0b7","modified":1751939069143},{"_id":"source/_posts/仓库迁移.md","hash":"12be881b0b63f35a5a17c8e1ffa906e8fad18f99","modified":1751939069143},{"_id":"source/_posts/week1-研发周报-作业管理详情页开发.md","hash":"b21c338910e46c9347106106dc94118183eaa7c3","modified":1752326670579},{"_id":"source/day1_react_learning-1.png","hash":"35bf397cf680e4f017ea3a03031ca2ba8fbfc703","modified":1752032876210},{"_id":"source/week1-研发周报-作业管理详情页开发-1.png","hash":"a543db820f14da6afb99664aa78b5ac6f893f14f","modified":1752322797940},{"_id":"source/cancerAI-1-3.png","hash":"7c3b7f61bfcb9c1dead2a052e0398e30b87b2036","modified":1752039325022},{"_id":"source/cancerAI-1-2.png","hash":"cf0c93027d22e6c298c53a1d2fe7cf7316e64f72","modified":1752039269397},{"_id":"source/day2-react-learning-1.png","hash":"1215d1462305bb24555c06d76d8d02193ee5c85f","modified":1752032285901},{"_id":"source/cancerAI-1-1.png","hash":"40b83a9b2e181b1e700cd6a2c58c8885d5920982","modified":1752039206289},{"_id":"source/cancerAI-1-4.png","hash":"4efadadf983ebd01d89444820d6dbc561c16888b","modified":1752039419899},{"_id":"node_modules/hexo-theme-vivia/README.zh-CN.md","hash":"af91b61243c77f174e5fa4f3bff47b72d61052dd","modified":1751939068280},{"_id":"node_modules/hexo-theme-vivia/README.md","hash":"7b9d473bf3f164593209cd7dd313dd0dc10a5038","modified":1751939068280},{"_id":"node_modules/hexo-theme-vivia/.gitattributes","hash":"78d61b8d5577d8909a33e526f0b968a5a6a81c1c","modified":1751939068279},{"_id":"node_modules/hexo-theme-vivia/example_config.vivia.yml","hash":"2d72d4d0bbb6fd3e5d82d26f11911c6c2b559ff4","modified":1751939068280},{"_id":"node_modules/hexo-theme-vivia/example_zh_CN_config.vivia.yml","hash":"2a9cff66640ac67853d80dbdc815ad9d40bbf854","modified":1751939068280},{"_id":"node_modules/hexo-theme-vivia/languages/en.yml","hash":"b3606fd1531f851419551b1eede2a7a2c4b06304","modified":1751939068280},{"_id":"node_modules/hexo-theme-vivia/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1751939068280},{"_id":"node_modules/hexo-theme-vivia/package.json","hash":"f25e6e9d9cb241028432f96f87bc764d124ab78e","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/languages/en-US.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1751939068280},{"_id":"node_modules/hexo-theme-vivia/LICENSE","hash":"dc75163d38c26492bbd3bd179b43dc6156489bf9","modified":1751939068279},{"_id":"node_modules/hexo-theme-vivia/languages/en-GB.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1751939068280},{"_id":"node_modules/hexo-theme-vivia/languages/zh.yml","hash":"e56bebd19d2abd1698e9aa87d337941957977468","modified":1751939068281},{"_id":"node_modules/hexo-theme-vivia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/languages/zh-CN.yml","hash":"6d3744d6c14eb2590249ed59892d06fbd1929a5a","modified":1751939068280},{"_id":"node_modules/hexo-theme-vivia/languages/zh-TW.yml","hash":"e652bd780c02c2ab3a25c834140618902ece1499","modified":1751939068281},{"_id":"node_modules/hexo-theme-vivia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/layout/layout.ejs","hash":"28faaa32bc5c16147b8163ff9281df7bc446b4bf","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/layout/index.ejs","hash":"855cf21ff57263654dc0c70271718c7dc2c04add","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/scripts/archive-helper.js","hash":"aa1c8841c64ec4cfdf084e4670471105baf8038a","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/scripts/color-generate.js","hash":"4437ea1ccf9159ececb4015cc6cc72a84e7a1930","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/scripts/categories-process.js","hash":"49f0b31b9fee537579d7329d1fe32a7e98886413","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/source/avatar.jpg","hash":"1266791ae8dc4dd620d03d2c6a56d078a1244df7","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/source/favicon.ico","hash":"6c4f53ed166e0a330d4931d77a58b09b8bdaf832","modified":1751939068305},{"_id":"node_modules/hexo-theme-vivia/layout/_icon/dark_mode.ejs","hash":"0ea0e23fb16103f424591cf46939fcf07738ccc1","modified":1751939068281},{"_id":"node_modules/hexo-theme-vivia/layout/_icon/menu.ejs","hash":"47f04d2c6413beaffee57d6164b5637bdb2cd1cb","modified":1751939068281},{"_id":"node_modules/hexo-theme-vivia/layout/_icon/wb_sunny.ejs","hash":"ef254cc64ba10918218a6672e34fd5f6d4ce08bb","modified":1751939068281},{"_id":"node_modules/hexo-theme-vivia/layout/_icon/navigate_next.ejs","hash":"c3ecb137ebc9bb949aebe3fc0631b05ba578c8e1","modified":1751939068281},{"_id":"node_modules/hexo-theme-vivia/layout/_icon/rss_feed.ejs","hash":"8bac3aa45c0e7a55f38783e7350039d0b1adb48b","modified":1751939068281},{"_id":"node_modules/hexo-theme-vivia/layout/_icon/navigate_before.ejs","hash":"1c11e29aa2719674b161c072e53576ac38b1ee65","modified":1751939068281},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/archive.ejs","hash":"b5d71356d87a8c3e6ff4effdf6c42609cb30856b","modified":1751939068281},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1751939068281},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/article.ejs","hash":"3b5cd0e22392375a2b78f565f09590463b794907","modified":1751939068281},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/banner.ejs","hash":"9656debca5f0f53c1982c6daab6a52e8923e7983","modified":1751939068282},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/back-to-top.ejs","hash":"7d9f69e8376cf84ee1f19828682c4782ed59a41a","modified":1751939068282},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/head.ejs","hash":"036e10adf7de2941fc63783225c5b3e46460c90c","modified":1751939068282},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/footer.ejs","hash":"3cf3b39dc04045df3cc7c92c95fe28463a856438","modified":1751939068282},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/baidu-analytics.ejs","hash":"41047fab0aae2d92b8614c1ef1423a4e83b900ea","modified":1751939068282},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/gauges-analytics.ejs","hash":"165008f72ed77f0da879d132563d763369d26472","modified":1751939068282},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/google-analytics.ejs","hash":"9fc18f1fd5bec16f8a3d30b0ce38458485c398b3","modified":1751939068282},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/mobile-nav.ejs","hash":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1751939068282},{"_id":"node_modules/hexo-theme-vivia/layout/_widget/archive.ejs","hash":"84779c10d867eedbe394f210e35dc06b44daab4b","modified":1751939068283},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/sidebar.ejs","hash":"5e6e850b6d7387bed437b5b3b803ddea0638dbf5","modified":1751939068283},{"_id":"node_modules/hexo-theme-vivia/layout/_widget/profile.ejs","hash":"edea2c26bb4ac3b8e925b7191bd871e119cb915a","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/layout/_widget/category.ejs","hash":"11cac02c0dfad00fc787452a8aa83ecf6e3da196","modified":1751939068283},{"_id":"node_modules/hexo-theme-vivia/layout/_widget/color.ejs","hash":"2358392430560df30299753537bc45891cf86977","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/layout/_widget/tag.ejs","hash":"c438b8fa917b77c70d1add9729a948e03608d2e6","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/layout/_widget/recent_posts.ejs","hash":"01a612252514f79fed35d2726e4e8c11882be0f3","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/navbar.ejs","hash":"bcd3762cf28aedde3a7c418e04249f9ba686e94e","modified":1751939068282},{"_id":"node_modules/hexo-theme-vivia/source/css/_variables.styl","hash":"f1f0c6e43aa6a4301b06ac7e54c4b39f26c4f5b8","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/source/css/_extend.styl","hash":"c9444428bac649cb155c5625f24936971f942124","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/source/css/style.styl","hash":"cb279b85e22e9ec70e1f14ba46650910822ccee3","modified":1751939068305},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-dark-180.png","hash":"4771a6bd0386924ad31719f8999c036b36ad5688","modified":1751939068305},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-dark-192.png","hash":"929acfdd6e69ceacdecf40a03ed520f826750c06","modified":1751939068305},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-dark-32.png","hash":"8ef87b664e5c6250e5badd7312fe192e30fe2e83","modified":1751939068305},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-dark-128.png","hash":"44cceeef5fddc81a613faf6caa53bac139a6b564","modified":1751939068305},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-light-128.png","hash":"9c93c4ac222da14ca4f43b2d54573ce4099a161b","modified":1751939068306},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-light-180.png","hash":"6b26caab1d036726beaf47510bada4cddf253b24","modified":1751939068306},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-light-192.png","hash":"0d5f76f309b6a0661d695d6bf4db8ef8a56e4ae5","modified":1751939068306},{"_id":"node_modules/hexo-theme-vivia/source/js/color.global.min.js","hash":"9f9484bee263e19d060552c42c79bb9e151b54a0","modified":1751939068307},{"_id":"node_modules/hexo-theme-vivia/source/images/tile.png","hash":"fbc016bfb004a5ca4a8c6f0b078ae320ec98ba20","modified":1751939068307},{"_id":"node_modules/hexo-theme-vivia/source/js/light-dark-switch.js","hash":"112842dd773019c91d6f4b32dcda7ae01ca8e05e","modified":1751939068308},{"_id":"node_modules/hexo-theme-vivia/source/js/load-settings.js","hash":"17fa6bd9a652f822348e00c6432d44db42828df0","modified":1751939068308},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-light-32.png","hash":"604915a91ddede7874d5dcfa4de0bc4b04ae5da6","modified":1751939068306},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/post/nav.ejs","hash":"4fda522abb4ad4a9814c77d35f4b6a07ab32508d","modified":1751939068283},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/post/category.ejs","hash":"c484df219ff1710c09db50ff48467a701aefabf1","modified":1751939068282},{"_id":"node_modules/hexo-theme-vivia/source/js/script.js","hash":"faef3cfd08d0628d0e0840a21a5a3fa4d6e1703d","modified":1751939068308},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/post/gallery.ejs","hash":"9e5d84a50745caeeae376cf8691ef20cc9d386cb","modified":1751939068283},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/post/title.ejs","hash":"112f1fed9afa71896a40f50a5eb8fe4e5d5fb1c0","modified":1751939068283},{"_id":"node_modules/hexo-theme-vivia/source/css/_util/config.styl","hash":"89e6fd381090c5b7fdae52856634abdc0fec360e","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/post/date.ejs","hash":"b82ba6d625fdce3e29d69ad888eddeb31c76b28b","modified":1751939068282},{"_id":"node_modules/hexo-theme-vivia/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1751939068283},{"_id":"node_modules/hexo-theme-vivia/source/css/_util/color.styl","hash":"2903c2d78117134174cacd830fc06971f6d6e6ca","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/archive.styl","hash":"e03cb2013f1e19257c9b4059004e6ef94b15de71","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/back-to-top.styl","hash":"ee750d68838670c4818fca0202fa432c3dd46526","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/comment.styl","hash":"df615699d04a4817f99d7d6b9de8ab5b391287bd","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/article.styl","hash":"a0fa537555d519a6d54d1a1599b8be908be6460a","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/highlight.styl","hash":"885df08cc8180cf1e597703682346d22ec7bddb3","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/main-title.styl","hash":"234912a312eeb3fbb519104edf9d08733efdd74a","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/header.styl","hash":"c4e459440d83a5041ac3243e9c24b6662adacf24","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/footer.styl","hash":"ad9294cf869c956e834e7ec31388c88763ec17c2","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/sidebar-bottom.styl","hash":"4132e25ba9680c4b911a01abc75f501cda3fa4f1","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/sidebar-aside.styl","hash":"5175242f56689999aa8db4282c6d29f53a17e44e","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/settings.styl","hash":"1b649aa855c08632a92b428ee1f65bdcb8cda905","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/sidebar.styl","hash":"d03ca7b9e56e2d3967b6214d42c229bdb6bdf98f","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/source/js/jquery-3.4.1.min.js","hash":"b15f7cfa79519756dff1ad22553fd0ed09024343","modified":1751939068308},{"_id":"node_modules/hexo-theme-vivia/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1751939068304},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1751939068304},{"_id":"source/headpic.jpg","hash":"9e2c72c5bd71b934ae134b621981a918281352f1","modified":1751939069143},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/Roboto-Medium.ttf","hash":"3c6a09fcc6a454924c81af7dff94fc6d399ed79b","modified":1751939068292},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1751939068292},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1751939068284},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/Roboto-Bold.ttf","hash":"62442a18a9fe9457c1afeabf683d263a691b7798","modified":1751939068292},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/Roboto-Regular.ttf","hash":"56c5c0d38bde4c1f1549dda43db37b09c608aad3","modified":1751939068292},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1751939068303},{"_id":"source/musicshare.jpg","hash":"adeef7aadc8aafb7d23aa36cd59d469b31d8f45c","modified":1751939069151},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1751939068302},{"_id":"source/cancerAI-2-1.png","hash":"23c26fa6be44cef72cebdbf681ff949191f51e96","modified":1752325958312},{"_id":"public/about/index.html","hash":"a2c24466a0361e58cc0fd4383b6b4b66fb3fbf95","modified":1752380231105},{"_id":"public/2025/07/12/cancerAI-2/index.html","hash":"c39a02cb002f46be981bbb39715891ee2090c5dd","modified":1752380231105},{"_id":"public/2025/07/12/week1-研发周报-作业管理详情页开发/index.html","hash":"76204686ff434627e18aa128d335c6b21ebfa58c","modified":1752380231105},{"_id":"public/2025/07/09/day2-react-learning/index.html","hash":"4e80bf46d4620c99741dbf10df55c48f3732d30d","modified":1752380231105},{"_id":"public/2025/07/08/day1-react-learning/index.html","hash":"8dde8f79da5b9a41987abdad275dcb8c1d7e5085","modified":1752380231105},{"_id":"public/2025/06/29/cancerAI_1/index.html","hash":"d9c30b3b1cbca80a50311513d70ae78e86f8dc12","modified":1752380231105},{"_id":"public/2025/05/22/github-actions/index.html","hash":"84415ee2855e976a740b8fab30ec160d3d345dae","modified":1752380231105},{"_id":"public/2025/04/29/仓库迁移/index.html","hash":"440420955bbc823f63c8e2dbb6ef2d87c6056121","modified":1752380231105},{"_id":"public/2025/04/28/pinia重构/index.html","hash":"d9be7526da2d6db70a542e4f46f4025ffb59debf","modified":1752380231105},{"_id":"public/2025/04/12/hello-world/index.html","hash":"82858de3f3985e00ac20edb1be39ec9148ced1c3","modified":1752380231105},{"_id":"public/archives/index.html","hash":"eec6b954772a6d7cbbb9d3978974c83e83d6627d","modified":1752380231105},{"_id":"public/archives/2025/index.html","hash":"c590a907ba5346e2925cfa87a1ad81be69989f94","modified":1752380231105},{"_id":"public/archives/2025/04/index.html","hash":"1e82a0b4ae513e878dd450dac2341749dd73eb02","modified":1752380231105},{"_id":"public/archives/2025/05/index.html","hash":"94eaeed1401125f2c12118d1546669886fac7402","modified":1752380231105},{"_id":"public/archives/2025/06/index.html","hash":"6976870129fe525cf7f22cd053b8c28ae2d76054","modified":1752380231105},{"_id":"public/archives/2025/07/index.html","hash":"3ad3fedbea2613d728dcd3b4d2dbc641d9c4e8f8","modified":1752380231105},{"_id":"public/index.html","hash":"7943dc1a99470beb2b5d17b66086ae915eb6132e","modified":1752380231105},{"_id":"public/tags/深度学习/index.html","hash":"4f694b4240a8a240f46cfa4a52f54f156e0d2e5f","modified":1752380231105},{"_id":"public/tags/AI医学/index.html","hash":"0484902a52b755e2059d10d65b32f258fbaadf28","modified":1752380231105},{"_id":"public/tags/react/index.html","hash":"f58d5e891557232ac4e8779ec2e27fa554628710","modified":1752380231105},{"_id":"public/tags/web前端/index.html","hash":"1be488e031d53056b10283622c88d763f3e453b8","modified":1752380231105},{"_id":"public/tags/实习日记/index.html","hash":"e04e5fd138321c8521736702fe509e7691f50dc3","modified":1752380231105},{"_id":"public/tags/git/index.html","hash":"b70ca78083e9e2fd1f1c1cbd6c89a5e539893ef4","modified":1752380231105},{"_id":"public/favicon.ico","hash":"6c4f53ed166e0a330d4931d77a58b09b8bdaf832","modified":1752380231105},{"_id":"public/images/favicon-dark-128.png","hash":"44cceeef5fddc81a613faf6caa53bac139a6b564","modified":1752380231105},{"_id":"public/images/favicon-dark-192.png","hash":"929acfdd6e69ceacdecf40a03ed520f826750c06","modified":1752380231105},{"_id":"public/avatar.jpg","hash":"1266791ae8dc4dd620d03d2c6a56d078a1244df7","modified":1752380231105},{"_id":"public/images/favicon-dark-180.png","hash":"4771a6bd0386924ad31719f8999c036b36ad5688","modified":1752380231105},{"_id":"public/images/favicon-dark-32.png","hash":"8ef87b664e5c6250e5badd7312fe192e30fe2e83","modified":1752380231105},{"_id":"public/images/favicon-light-128.png","hash":"9c93c4ac222da14ca4f43b2d54573ce4099a161b","modified":1752380231105},{"_id":"public/images/favicon-light-180.png","hash":"6b26caab1d036726beaf47510bada4cddf253b24","modified":1752380231105},{"_id":"public/images/favicon-light-192.png","hash":"0d5f76f309b6a0661d695d6bf4db8ef8a56e4ae5","modified":1752380231105},{"_id":"public/images/favicon-light-32.png","hash":"604915a91ddede7874d5dcfa4de0bc4b04ae5da6","modified":1752380231105},{"_id":"public/images/tile.png","hash":"fbc016bfb004a5ca4a8c6f0b078ae320ec98ba20","modified":1752380231105},{"_id":"public/cancerAI-2-2.png","hash":"efa5ea0d8e6377df29fd6c0217ad125ad22cd759","modified":1752380231105},{"_id":"public/day1_react_learning-2.png","hash":"2893dd3e1ef55c2bd2ba4010aaf64c16ef3d161f","modified":1752380231105},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1752380231105},{"_id":"public/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1752380231105},{"_id":"public/day1_react_learning-1.png","hash":"35bf397cf680e4f017ea3a03031ca2ba8fbfc703","modified":1752380231105},{"_id":"public/week1-研发周报-作业管理详情页开发-1.png","hash":"a543db820f14da6afb99664aa78b5ac6f893f14f","modified":1752380231105},{"_id":"public/js/color.global.min.js","hash":"8140005be5afebb828b2890ce6e686ece34e78df","modified":1752380231105},{"_id":"public/js/load-settings.js","hash":"f420677aad3d200b4f92fca60ab5cb47c7db9a21","modified":1752380231105},{"_id":"public/css/style.css","hash":"731b58e1ae2e40d7aeadb62318fbf13af15619fb","modified":1752380231105},{"_id":"public/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1752380231105},{"_id":"public/js/light-dark-switch.js","hash":"371eacee9af459d04de60190c549fe7f8374be36","modified":1752380231105},{"_id":"public/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1752380231105},{"_id":"public/css/fonts/Roboto-Bold.ttf","hash":"62442a18a9fe9457c1afeabf683d263a691b7798","modified":1752380231105},{"_id":"public/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1752380231105},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1752380231105},{"_id":"public/css/fonts/Roboto-Medium.ttf","hash":"3c6a09fcc6a454924c81af7dff94fc6d399ed79b","modified":1752380231105},{"_id":"public/css/fonts/Roboto-Regular.ttf","hash":"56c5c0d38bde4c1f1549dda43db37b09c608aad3","modified":1752380231105},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1752380231105},{"_id":"public/cancerAI-1-3.png","hash":"7c3b7f61bfcb9c1dead2a052e0398e30b87b2036","modified":1752380231105},{"_id":"public/cancerAI-1-2.png","hash":"cf0c93027d22e6c298c53a1d2fe7cf7316e64f72","modified":1752380231105},{"_id":"public/day2-react-learning-1.png","hash":"1215d1462305bb24555c06d76d8d02193ee5c85f","modified":1752380231105},{"_id":"public/cancerAI-1-1.png","hash":"40b83a9b2e181b1e700cd6a2c58c8885d5920982","modified":1752380231105},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1752380231105},{"_id":"public/cancerAI-1-4.png","hash":"4efadadf983ebd01d89444820d6dbc561c16888b","modified":1752380231105},{"_id":"public/headpic.jpg","hash":"9e2c72c5bd71b934ae134b621981a918281352f1","modified":1752380231105},{"_id":"public/musicshare.jpg","hash":"adeef7aadc8aafb7d23aa36cd59d469b31d8f45c","modified":1752380231105},{"_id":"public/cancerAI-2-1.png","hash":"23c26fa6be44cef72cebdbf681ff949191f51e96","modified":1752380231105}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2025-04-28T03:31:59.000Z","_content":"### 最近在听：\nhttps://music.163.com/playlist?id=13032942246&uct2=U2FsdGVkX18jLF6G3jNcU4ngOvA+ZmMUnndaAVd7KRM=\n![歌单分享](musicshare.jpg)\n\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2025-04-28 11:31:59\n---\n### 最近在听：\nhttps://music.163.com/playlist?id=13032942246&uct2=U2FsdGVkX18jLF6G3jNcU4ngOvA+ZmMUnndaAVd7KRM=\n![歌单分享](musicshare.jpg)\n\n\n","updated":"2025-07-08T01:44:29.143Z","path":"about/index.html","comments":1,"layout":"page","_id":"cmd15y0w40000lstv1en427ex","content":"<h3 id=\"最近在听：\"><a href=\"#最近在听：\" class=\"headerlink\" title=\"最近在听：\"></a>最近在听：</h3><p><a href=\"https://music.163.com/playlist?id=13032942246&uct2=U2FsdGVkX18jLF6G3jNcU4ngOvA+ZmMUnndaAVd7KRM=\">https://music.163.com/playlist?id=13032942246&amp;uct2=U2FsdGVkX18jLF6G3jNcU4ngOvA+ZmMUnndaAVd7KRM=</a><br><img src=\"/blog/musicshare.jpg\" alt=\"歌单分享\"></p>\n","length":104,"excerpt":"","more":"<h3 id=\"最近在听：\"><a href=\"#最近在听：\" class=\"headerlink\" title=\"最近在听：\"></a>最近在听：</h3><p><a href=\"https://music.163.com/playlist?id=13032942246&uct2=U2FsdGVkX18jLF6G3jNcU4ngOvA+ZmMUnndaAVd7KRM=\">https://music.163.com/playlist?id=13032942246&amp;uct2=U2FsdGVkX18jLF6G3jNcU4ngOvA+ZmMUnndaAVd7KRM=</a><br><img src=\"/blog/musicshare.jpg\" alt=\"歌单分享\"></p>\n"}],"Post":[{"title":"多模态数字病理图像（H&E 与多重荧光）配准方法探索进度报告1","date":"2025-06-29T05:31:25.000Z","_content":"**主题：** 多模态数字病理图像（H&E 与多重荧光）配准方法探索进度报告\n\n**任务目标：**\n\n对齐不同染色模态下的小鼠肝脏组织切片图像，具体包括一张来自 3DHISTECH Pannoramic 扫描仪的 H&E 染色图像（.mrsx 格式）与一张多重荧光染色图像（源文件为 .tiff.tiff 格式，包含 7 个通道）。\n\n> 想象一下，你有两张部分透明的地图，一张是显示城市轮廓和主干道的“地形图”（H&E苏木精通道，主要显示细胞核的形态），另一张是只标注了所有河流位置的“水文图”（DAPI通道，专门标记细胞核DNA）。这两张图描绘的是同一个区域，但因为是分开绘制的，当你把它们叠在一起时，会发现河流并没有恰好流经城市峡谷，而是有所偏移和旋转。\n\n图像配准（Image Registration） 的任务，就是通过电脑自动地移动、旋转、缩放这张“水文图”，直到它与“地形图”上的对应结构完美重合。\n\n由于涉及全玻片图像（Whole Slide Images, WSI）的**巨大尺寸和专有文件格式**的读取挑战，本阶段的工作重点首先聚焦于在选定的**局部组织区域**内探索并实现有效的配准策略，为后续的全玻片级别配准奠定技术基础。\n\n**研究方法与实施：**\n\n为了规避直接处理复杂 WSI 格式的难题，并控制计算资源，我首先采用数字病理图像处理软件（Imagescope 和 QuPath）提取了两张图像中**高度重叠**的局部区域。具体操作包括：\n\n1.  从 H&E 图像（.mrsx）中截取一块代表性组织区域，并导出为标准的 **TIFF 格式**图像（HCC0-1-HE-1.png）。\n\n![alt text](cancerAI-1-1.png)\n\n2.从多重荧光图像（.tiff.tiff），特别是聚焦于**细胞核染色通道**（根据元数据，该通道包含了与 H&E 苏木素染色相对应的细胞核信息，此处使用了导出后可正常显示的 JPG 格式， HCC0-1-IHC-1.jpg），截取与上述 H&E 区域高度对应的局部图像。\n\n![alt text](cancerAI-1-2.png)\n\n这些局部图像被用作后续配准算法的输入。我探索了两种主流的图像配准策略：\n\n1.  **基于局部特征的配准 (Feature-Based Registration) 探索：**\n    \n    - **原理：** 该方法旨在通过识别两张图像中独特的**局部模式**（特征点），计算其特征描述符，然后在描述符空间中寻找最相似的匹配对。理想情况下，这些匹配对对应于两张图像中同一物理位置的结构。通过这些对应点，可以计算出将源图像映射到目标图像的最佳几何变换。\n\n    - **Python：**\n    \n      - 我们编写 Python 代码，利用 OpenCV 库实现基于 SIFT (Scale-Invariant Feature Transform) 特征的配准流程。SIFT 因其对尺度和旋转的不变性，常被用于不同视角或模态的图像配准。\n    \n      - 首先，对 H&E 局部图像进行颜色解卷积，提取苏木素通道（反映**细胞核分布**）。荧光局部图像被转换为**灰度图**，作为代表细胞核信息的输入。\n    \n        ![alt text](cancerAI-1-3.png)\n    \n      - 使用 cv2.SIFT_create 检测两张灰度图像中的关键点，并计算它们的 SIFT 描述符。\n    \n      - 使用 cv2.BFMatcher (Brute Force Matcher) 结合 KNN 算法在描述符空间中进行匹配，并应用比率测试（Ratio Test）筛选出初步的“好”匹配对。\n    \n      - 尝试使用 cv2.findHomography 函数结合 RANSAC (Random Sample Consensus) 算法，从筛选后的匹配对中估计一个鲁棒的单应性变换矩阵，同时剔除不符合该模型的“外点”。\n    \n      - **调试与输出：** 输出显示，两张图像都成功加载（H&E 图像尺寸为 512x535 像素，荧光图像尺寸为 4551x4492 像素）并提取了特征点。经过比率测试后，从上千对潜在匹配中仅筛选出了 **1 对**符合条件的“好”匹配点。由于计算单应性变换**至少需要 4 对对应点**，因此配准过程在估计变换矩阵阶段因缺乏足够的有效输入而直接失败。\n    \n      ![alt text](cancerAI-1-4.png)\n    \n    - **Fiji ：**\n    \n      - 考虑到可能是代码实现细节或库版本问题，我们进一步尝试在广泛用于生物医学图像处理的 Fiji (ImageJ) 软件中，使用其成熟的 SIFT 配准插件进行验证。\n    \n      - 我们按照 Fiji 官方推荐的步骤操作：首先使用 Plugins > Feature Extraction > Extract SIFT Correspondences 提取并匹配 SIFT 特征，然后使用 Plugins > Registration > Linear Stack Alignment with SIFT 应用这些匹配进行线性（通常是仿射）对齐。\n    \n      - **输出：** Fiji 的 SIFT 插件输出了详细的匹配过程信息，与代码中的观察高度一致：\n    \n        ```\n        Processing SIFT ... took 1165ms. 7006 features extracted.\n        Processing SIFT ... took 148ms. 382 features extracted.\n        Identifying correspondence candidates using brute force ... took 197ms. 52 potentially corresponding features identified.\n        Filtering correspondence candidates by geometric consensus ... took 2ms. No correspondences found.\n        Processing SIFT ... took 1000ms. 7006 features extracted.\n        Done.\n        ```\n    \n        尽管在两张图像中分别提取了 7006 和 382 个特征点，并找到了 52 对潜在匹配，但在进行几何一致性过滤后，**没有找到任何一对有效的对应点（\"No correspondences found\"）**。\n    \n      - **分析：** Fiji 作为成熟的图像处理平台，其 SIFT 插件的失败结果进一步有力地证实了基于 SIFT 特征匹配的方法在当前这对 H&E 与荧光局部图像上确实难以奏效。问题根源不在于 SIFT 算法本身或实现细节，而在于两张图像的内在属性——**不同染色模态导致的微观纹理差异过大**，使得 SIFT 描述符不足以捕捉到在不同图像间具有一致几何关系的特征，即使少量描述符相似，其空间位置也无法用一个简单的线性变换（如仿射或单应性）来解释。\n    \n    \n    \n2.  **基于图像强度的配准 (Intensity-Based Registration)：**\n    * **原理：** 与基于特征的方法不同，该方法不依赖于离散的特征点，而是**直接利用图像的像素强度信息**。它通过迭代地调整一个预设的几何变换模型的参数（例如平移、旋转、缩放、透视），寻找能够最大化两张图像（源图像变换后与目标图像）之间相似性度量（如增强相关性系数 ECC）的变换参数。\n    \n      > 宏观结构（如组织边界、血管轮廓、大的细胞团块）会在图像中形成显著的像素强度对比和梯度变化区域。如果这些宏观结构在两张图像中都能清晰可见，并且它们形成的强度模式具有一定的相似性，基于强度的算法**可能**能够利用这些信息进行对齐。可以说它**间接**利用了宏观结构，因为它处理的是构成这些结构的像素信息。\n      >\n    \n    * **实施：** 我们使用了 OpenCV 库提供的 `findTransformECC` 函数。为了全面评估该方法在不同形变假设下的性能，我们系统地尝试了多种运动模型，包括：\n    \n      *   `cv2.MOTION_TRANSLATION` (仅平移)\n      *   `cv2.MOTION_EUCLIDEAN` (平移 + 旋转)\n      *   `cv2.MOTION_AFFINE` (平移 + 旋转 + 缩放 + 剪切)\n      *   `cv2.MOTION_HOMOGRAPHY` (仿射 + 透视)\n    \n    * 输入图像为经过预处理的 H&E 苏木素通道和荧光灰度图。预处理步骤包括直方图均衡化（增强对比度）和高斯模糊（减少噪声），以希望提高算法收敛性。\n    \n    *   系统性地尝试了 TRANSLATION, EUCLIDEAN, AFFINE, HOMOGRAPHY 四种运动模型，试图探索不同复杂度的形变模型是否能找到有效的对齐。\n    \n    *   **分析**：两张图像在像素强度层面的**局部变化模式**仍然存在显著差异，不足以驱动 ECC 算法通过迭代优化找到有效的对齐。预处理（直方图均衡化、高斯模糊）未能弥合这种根本性的模态差异。\n    \n    ```\n    2025-06-26 20:23:07,716 - INFO - 开始增强的图像配准程序\n    2025-06-26 20:23:07,717 - INFO - 输出目录: output_patch_registration_enhanced\n    2025-06-26 20:23:07,717 - INFO - ==================================================\n    2025-06-26 20:23:07,717 - INFO - 步骤 1: 加载图像\n    2025-06-26 20:23:07,718 - INFO - 加载 H&E 图像: F:/BaiduNetdiskDownload/HCC0-1/HCC0-1-HE-1.png\n    2025-06-26 20:23:07,748 - INFO - H&E RGB 统计信息:\n    2025-06-26 20:23:07,748 - INFO -   形状: (512, 535, 3), 类型: uint8\n    2025-06-26 20:23:07,748 - INFO -   均值: 204.676, 标准差: 49.826\n    2025-06-26 20:23:07,749 - INFO -   范围: [0.000, 255.000]\n    2025-06-26 20:23:07,749 - INFO - 加载荧光图像: F:/BaiduNetdiskDownload/HCC0-1/HCC0-1-IHC-3.jpg\n    2025-06-26 20:23:07,754 - INFO - 荧光灰度 统计信息:\n    2025-06-26 20:23:07,754 - INFO -   形状: (569, 562), 类型: uint8\n    2025-06-26 20:23:07,755 - INFO -   均值: 79.511, 标准差: 62.615\n    2025-06-26 20:23:07,755 - INFO -   范围: [0.000, 255.000]\n    2025-06-26 20:23:07,755 - INFO - ==================================================\n    2025-06-26 20:23:07,756 - INFO - 步骤 2: 图像预处理\n    2025-06-26 20:23:07,756 - INFO - 开始H&E颜色解卷积处理...\n    2025-06-26 20:23:07,771 - INFO - 染色矩阵 ruifrok: 苏木素OD范围 [0.000, 0.150]\n    2025-06-26 20:23:07,780 - INFO - 保存调试图像: output_patch_registration_enhanced\\debug_he_hematoxylin_ruifrok.png\n    2025-06-26 20:23:07,791 - INFO - 染色矩阵 macenko: 苏木素OD范围 [0.000, 0.154]\n    2025-06-26 20:23:07,800 - INFO - 保存调试图像: output_patch_registration_enhanced\\debug_he_hematoxylin_macenko.png\n    2025-06-26 20:23:07,801 - INFO - H&E解卷积完成，返回形状: (512, 535)\n    2025-06-26 20:23:07,802 - INFO - 应用直方图均衡化\n    2025-06-26 20:23:07,804 - INFO - 应用高斯模糊，核大小: 3\n    2025-06-26 20:23:07,806 - INFO - 应用直方图均衡化\n    2025-06-26 20:23:07,806 - INFO - 应用高斯模糊，核大小: 3\n    2025-06-26 20:23:07,809 - INFO - 预处理后H&E 统计信息:\n    2025-06-26 20:23:07,810 - INFO -   形状: (512, 535), 类型: float32\n    2025-06-26 20:23:07,810 - INFO -   均值: 133.401, 标准差: 71.034\n    2025-06-26 20:23:07,810 - INFO -   范围: [1.000, 255.000]\n    2025-06-26 20:23:07,811 - INFO - 预处理后荧光 统计信息:\n    2025-06-26 20:23:07,811 - INFO -   形状: (569, 562), 类型: float32\n    2025-06-26 20:23:07,812 - INFO -   均值: 128.171, 标准差: 69.131\n    2025-06-26 20:23:07,812 - INFO -   范围: [0.000, 255.000]\n    2025-06-26 20:23:07,818 - INFO - 预处理图像已保存\n    2025-06-26 20:23:07,818 - INFO - ==================================================\n    2025-06-26 20:23:07,819 - INFO - 步骤 3: 执行图像配准\n    2025-06-26 20:23:07,819 - INFO - 尝试多种运动模型进行配准...\n    2025-06-26 20:23:07,819 - INFO - 开始 TRANSLATION 配准...\n    2025-06-26 20:23:07,839 - ERROR - TRANSLATION 配准失败: OpenCV(4.10.0) D:\\a\\opencv-python\\opencv-python\\opencv\\modules\\video\\src\\ecc.cpp:589: error: (-7:Iterations do not converge) The algorithm stopped before its convergence. The correlation is going to be minimized. Images may be uncorrelated or non-overlapped in function 'cv::findTransformECC'\n    \n    2025-06-26 20:23:07,839 - INFO - 失败耗时: 0.02秒\n    2025-06-26 20:23:07,840 - INFO - 开始 EUCLIDEAN 配准...\n    2025-06-26 20:23:07,852 - ERROR - EUCLIDEAN 配准失败: OpenCV(4.10.0) D:\\a\\opencv-python\\opencv-python\\opencv\\modules\\video\\src\\ecc.cpp:589: error: (-7:Iterations do not converge) The algorithm stopped before its convergence. The correlation is going to be minimized. Images may be uncorrelated or non-overlapped in function 'cv::findTransformECC'\n    \n    2025-06-26 20:23:07,852 - INFO - 失败耗时: 0.01秒\n    2025-06-26 20:23:07,853 - INFO - 开始 AFFINE 配准...\n    2025-06-26 20:23:07,868 - ERROR - AFFINE 配准失败: OpenCV(4.10.0) D:\\a\\opencv-python\\opencv-python\\opencv\\modules\\video\\src\\ecc.cpp:589: error: (-7:Iterations do not converge) The algorithm stopped before its convergence. The correlation is going to be minimized. Images may be uncorrelated or non-overlapped in function 'cv::findTransformECC'\n    \n    2025-06-26 20:23:07,868 - INFO - 失败耗时: 0.01秒\n    2025-06-26 20:23:07,869 - INFO - 开始 HOMOGRAPHY 配准...\n    2025-06-26 20:23:07,893 - ERROR - HOMOGRAPHY 配准失败: OpenCV(4.10.0) D:\\a\\opencv-python\\opencv-python\\opencv\\modules\\video\\src\\ecc.cpp:589: error: (-7:Iterations do not converge) The algorithm stopped before its convergence. The correlation is going to be minimized. Images may be uncorrelated or non-overlapped in function 'cv::findTransformECC'\n    \n    2025-06-26 20:23:07,894 - INFO - 失败耗时: 0.02秒\n    2025-06-26 20:23:07,894 - ERROR - 所有运动模型配准均失败\n    2025-06-26 20:23:07,894 - ERROR - 所有配准方法均失败\n    \n    ```\n    \n    \n\n**结果与分析：**\n\n尽管我们采用了多种策略并进行了代码增强，当前阶段在所选取的局部图像上实现自动配准的尝试尚未取得成功：\n\n1.  **基于局部特征的配准结果：**\n    *   在两张局部图像中均成功检测到大量 SIFT 特征点（分别为 3544 和 2793 个特征点）。\n    *   初步的描述符匹配识别出 88 对潜在的对应特征。\n    *   然而，在进行几何一致性筛选后，未能找到任何一对符合全局几何变换模型的内点（\"No correspondences found\"）。\n    *   **分析：** 这一结果与我们肉眼观察到的现象吻合——H&E 和荧光图像虽然是同一组织区域，但细胞核在两种染色模态下的微观形态差异显著，导致基于局部纹理的 SIFT 描述符不足以建立可靠的对应关系。即使找到少量描述符相似的特征点，它们在两张图像中的空间分布也缺乏整体的一致性，无法用一个简单的几何变换解释。\n2.  **基于图像强度的配准（ECC）结果：**\n    *   我们系统地尝试了 TRANSLATION, EUCLIDEAN, AFFINE 和 HOMOGRAPHY 四种运动模型进行 ECC 配准。\n    *   遗憾的是，所有尝试均未能收敛到有效的变换矩阵，并报告了 `(-7:Iterations do not converge)` 错误，提示 \"Images may be uncorrelated or non-overlapped\"。\n    *   **分析：** 尽管使用了 H&E 苏木素通道和荧光灰度图（理论上都突出细胞核），并尝试了直方图均衡化和高斯模糊预处理，两张图像之间的像素强度相关性仍然不足以驱动 ECC 算法收敛。这可能的原因包括：\n        *   两张图像的像素强度分布和纹理模式在局部区域差异较大，即使是细胞核，其在 H&E 灰度图和荧光灰度图中的具体像素值变化模式可能差异显著。\n        *   虽然整体形状相似，但如果局部存在复杂的非线性形变，超出了 HOMOGRAPHY 模型的表达能力，ECC 也难以找到合适的变换。\n        *   所选取的局部区域在像素强度层面可能缺乏足够的、在两张图像中都能稳定对应的变化模式。\n\n**下一步计划：**\n\n鉴于自动特征匹配和基于强度的 ECC 方法在当前局部图像上均遭遇困难，但我们观察到两张切片的整体形态是相似的，我们将调整策略，重点探索利用宏观结构信息进行配准：\n\n**探索基于手动标记点的配准 (Manual Landmark-Based Registration)：** 利用我们肉眼识别两张图像中共同宏观结构（如血管分支、组织边界、大的细胞团块边缘等）的能力，在两张图像中手动选取至少四对对应的点。\n\n*   **方法：** 可以借助专业的图像处理软件如 ImageJ/Fiji 或 QuPath 的手动标记点功能，导出对应点的坐标。然后使用这些坐标点，通过 `cv2.findHomography` 或 `cv2.getAffineTransform` 在 Python 中计算变换矩阵。\n*   **优势：** 这种方法不受模态差异导致的微观纹理不匹配影响，直接利用了可靠的宏观对应信息，有望获得更准确的初始对齐。","source":"_posts/cancerAI_1.md","raw":"---\ntitle: 多模态数字病理图像（H&E 与多重荧光）配准方法探索进度报告1\ndate: 2025-06-29 13:31:25\ntags: [深度学习, AI医学]\n---\n**主题：** 多模态数字病理图像（H&E 与多重荧光）配准方法探索进度报告\n\n**任务目标：**\n\n对齐不同染色模态下的小鼠肝脏组织切片图像，具体包括一张来自 3DHISTECH Pannoramic 扫描仪的 H&E 染色图像（.mrsx 格式）与一张多重荧光染色图像（源文件为 .tiff.tiff 格式，包含 7 个通道）。\n\n> 想象一下，你有两张部分透明的地图，一张是显示城市轮廓和主干道的“地形图”（H&E苏木精通道，主要显示细胞核的形态），另一张是只标注了所有河流位置的“水文图”（DAPI通道，专门标记细胞核DNA）。这两张图描绘的是同一个区域，但因为是分开绘制的，当你把它们叠在一起时，会发现河流并没有恰好流经城市峡谷，而是有所偏移和旋转。\n\n图像配准（Image Registration） 的任务，就是通过电脑自动地移动、旋转、缩放这张“水文图”，直到它与“地形图”上的对应结构完美重合。\n\n由于涉及全玻片图像（Whole Slide Images, WSI）的**巨大尺寸和专有文件格式**的读取挑战，本阶段的工作重点首先聚焦于在选定的**局部组织区域**内探索并实现有效的配准策略，为后续的全玻片级别配准奠定技术基础。\n\n**研究方法与实施：**\n\n为了规避直接处理复杂 WSI 格式的难题，并控制计算资源，我首先采用数字病理图像处理软件（Imagescope 和 QuPath）提取了两张图像中**高度重叠**的局部区域。具体操作包括：\n\n1.  从 H&E 图像（.mrsx）中截取一块代表性组织区域，并导出为标准的 **TIFF 格式**图像（HCC0-1-HE-1.png）。\n\n![alt text](cancerAI-1-1.png)\n\n2.从多重荧光图像（.tiff.tiff），特别是聚焦于**细胞核染色通道**（根据元数据，该通道包含了与 H&E 苏木素染色相对应的细胞核信息，此处使用了导出后可正常显示的 JPG 格式， HCC0-1-IHC-1.jpg），截取与上述 H&E 区域高度对应的局部图像。\n\n![alt text](cancerAI-1-2.png)\n\n这些局部图像被用作后续配准算法的输入。我探索了两种主流的图像配准策略：\n\n1.  **基于局部特征的配准 (Feature-Based Registration) 探索：**\n    \n    - **原理：** 该方法旨在通过识别两张图像中独特的**局部模式**（特征点），计算其特征描述符，然后在描述符空间中寻找最相似的匹配对。理想情况下，这些匹配对对应于两张图像中同一物理位置的结构。通过这些对应点，可以计算出将源图像映射到目标图像的最佳几何变换。\n\n    - **Python：**\n    \n      - 我们编写 Python 代码，利用 OpenCV 库实现基于 SIFT (Scale-Invariant Feature Transform) 特征的配准流程。SIFT 因其对尺度和旋转的不变性，常被用于不同视角或模态的图像配准。\n    \n      - 首先，对 H&E 局部图像进行颜色解卷积，提取苏木素通道（反映**细胞核分布**）。荧光局部图像被转换为**灰度图**，作为代表细胞核信息的输入。\n    \n        ![alt text](cancerAI-1-3.png)\n    \n      - 使用 cv2.SIFT_create 检测两张灰度图像中的关键点，并计算它们的 SIFT 描述符。\n    \n      - 使用 cv2.BFMatcher (Brute Force Matcher) 结合 KNN 算法在描述符空间中进行匹配，并应用比率测试（Ratio Test）筛选出初步的“好”匹配对。\n    \n      - 尝试使用 cv2.findHomography 函数结合 RANSAC (Random Sample Consensus) 算法，从筛选后的匹配对中估计一个鲁棒的单应性变换矩阵，同时剔除不符合该模型的“外点”。\n    \n      - **调试与输出：** 输出显示，两张图像都成功加载（H&E 图像尺寸为 512x535 像素，荧光图像尺寸为 4551x4492 像素）并提取了特征点。经过比率测试后，从上千对潜在匹配中仅筛选出了 **1 对**符合条件的“好”匹配点。由于计算单应性变换**至少需要 4 对对应点**，因此配准过程在估计变换矩阵阶段因缺乏足够的有效输入而直接失败。\n    \n      ![alt text](cancerAI-1-4.png)\n    \n    - **Fiji ：**\n    \n      - 考虑到可能是代码实现细节或库版本问题，我们进一步尝试在广泛用于生物医学图像处理的 Fiji (ImageJ) 软件中，使用其成熟的 SIFT 配准插件进行验证。\n    \n      - 我们按照 Fiji 官方推荐的步骤操作：首先使用 Plugins > Feature Extraction > Extract SIFT Correspondences 提取并匹配 SIFT 特征，然后使用 Plugins > Registration > Linear Stack Alignment with SIFT 应用这些匹配进行线性（通常是仿射）对齐。\n    \n      - **输出：** Fiji 的 SIFT 插件输出了详细的匹配过程信息，与代码中的观察高度一致：\n    \n        ```\n        Processing SIFT ... took 1165ms. 7006 features extracted.\n        Processing SIFT ... took 148ms. 382 features extracted.\n        Identifying correspondence candidates using brute force ... took 197ms. 52 potentially corresponding features identified.\n        Filtering correspondence candidates by geometric consensus ... took 2ms. No correspondences found.\n        Processing SIFT ... took 1000ms. 7006 features extracted.\n        Done.\n        ```\n    \n        尽管在两张图像中分别提取了 7006 和 382 个特征点，并找到了 52 对潜在匹配，但在进行几何一致性过滤后，**没有找到任何一对有效的对应点（\"No correspondences found\"）**。\n    \n      - **分析：** Fiji 作为成熟的图像处理平台，其 SIFT 插件的失败结果进一步有力地证实了基于 SIFT 特征匹配的方法在当前这对 H&E 与荧光局部图像上确实难以奏效。问题根源不在于 SIFT 算法本身或实现细节，而在于两张图像的内在属性——**不同染色模态导致的微观纹理差异过大**，使得 SIFT 描述符不足以捕捉到在不同图像间具有一致几何关系的特征，即使少量描述符相似，其空间位置也无法用一个简单的线性变换（如仿射或单应性）来解释。\n    \n    \n    \n2.  **基于图像强度的配准 (Intensity-Based Registration)：**\n    * **原理：** 与基于特征的方法不同，该方法不依赖于离散的特征点，而是**直接利用图像的像素强度信息**。它通过迭代地调整一个预设的几何变换模型的参数（例如平移、旋转、缩放、透视），寻找能够最大化两张图像（源图像变换后与目标图像）之间相似性度量（如增强相关性系数 ECC）的变换参数。\n    \n      > 宏观结构（如组织边界、血管轮廓、大的细胞团块）会在图像中形成显著的像素强度对比和梯度变化区域。如果这些宏观结构在两张图像中都能清晰可见，并且它们形成的强度模式具有一定的相似性，基于强度的算法**可能**能够利用这些信息进行对齐。可以说它**间接**利用了宏观结构，因为它处理的是构成这些结构的像素信息。\n      >\n    \n    * **实施：** 我们使用了 OpenCV 库提供的 `findTransformECC` 函数。为了全面评估该方法在不同形变假设下的性能，我们系统地尝试了多种运动模型，包括：\n    \n      *   `cv2.MOTION_TRANSLATION` (仅平移)\n      *   `cv2.MOTION_EUCLIDEAN` (平移 + 旋转)\n      *   `cv2.MOTION_AFFINE` (平移 + 旋转 + 缩放 + 剪切)\n      *   `cv2.MOTION_HOMOGRAPHY` (仿射 + 透视)\n    \n    * 输入图像为经过预处理的 H&E 苏木素通道和荧光灰度图。预处理步骤包括直方图均衡化（增强对比度）和高斯模糊（减少噪声），以希望提高算法收敛性。\n    \n    *   系统性地尝试了 TRANSLATION, EUCLIDEAN, AFFINE, HOMOGRAPHY 四种运动模型，试图探索不同复杂度的形变模型是否能找到有效的对齐。\n    \n    *   **分析**：两张图像在像素强度层面的**局部变化模式**仍然存在显著差异，不足以驱动 ECC 算法通过迭代优化找到有效的对齐。预处理（直方图均衡化、高斯模糊）未能弥合这种根本性的模态差异。\n    \n    ```\n    2025-06-26 20:23:07,716 - INFO - 开始增强的图像配准程序\n    2025-06-26 20:23:07,717 - INFO - 输出目录: output_patch_registration_enhanced\n    2025-06-26 20:23:07,717 - INFO - ==================================================\n    2025-06-26 20:23:07,717 - INFO - 步骤 1: 加载图像\n    2025-06-26 20:23:07,718 - INFO - 加载 H&E 图像: F:/BaiduNetdiskDownload/HCC0-1/HCC0-1-HE-1.png\n    2025-06-26 20:23:07,748 - INFO - H&E RGB 统计信息:\n    2025-06-26 20:23:07,748 - INFO -   形状: (512, 535, 3), 类型: uint8\n    2025-06-26 20:23:07,748 - INFO -   均值: 204.676, 标准差: 49.826\n    2025-06-26 20:23:07,749 - INFO -   范围: [0.000, 255.000]\n    2025-06-26 20:23:07,749 - INFO - 加载荧光图像: F:/BaiduNetdiskDownload/HCC0-1/HCC0-1-IHC-3.jpg\n    2025-06-26 20:23:07,754 - INFO - 荧光灰度 统计信息:\n    2025-06-26 20:23:07,754 - INFO -   形状: (569, 562), 类型: uint8\n    2025-06-26 20:23:07,755 - INFO -   均值: 79.511, 标准差: 62.615\n    2025-06-26 20:23:07,755 - INFO -   范围: [0.000, 255.000]\n    2025-06-26 20:23:07,755 - INFO - ==================================================\n    2025-06-26 20:23:07,756 - INFO - 步骤 2: 图像预处理\n    2025-06-26 20:23:07,756 - INFO - 开始H&E颜色解卷积处理...\n    2025-06-26 20:23:07,771 - INFO - 染色矩阵 ruifrok: 苏木素OD范围 [0.000, 0.150]\n    2025-06-26 20:23:07,780 - INFO - 保存调试图像: output_patch_registration_enhanced\\debug_he_hematoxylin_ruifrok.png\n    2025-06-26 20:23:07,791 - INFO - 染色矩阵 macenko: 苏木素OD范围 [0.000, 0.154]\n    2025-06-26 20:23:07,800 - INFO - 保存调试图像: output_patch_registration_enhanced\\debug_he_hematoxylin_macenko.png\n    2025-06-26 20:23:07,801 - INFO - H&E解卷积完成，返回形状: (512, 535)\n    2025-06-26 20:23:07,802 - INFO - 应用直方图均衡化\n    2025-06-26 20:23:07,804 - INFO - 应用高斯模糊，核大小: 3\n    2025-06-26 20:23:07,806 - INFO - 应用直方图均衡化\n    2025-06-26 20:23:07,806 - INFO - 应用高斯模糊，核大小: 3\n    2025-06-26 20:23:07,809 - INFO - 预处理后H&E 统计信息:\n    2025-06-26 20:23:07,810 - INFO -   形状: (512, 535), 类型: float32\n    2025-06-26 20:23:07,810 - INFO -   均值: 133.401, 标准差: 71.034\n    2025-06-26 20:23:07,810 - INFO -   范围: [1.000, 255.000]\n    2025-06-26 20:23:07,811 - INFO - 预处理后荧光 统计信息:\n    2025-06-26 20:23:07,811 - INFO -   形状: (569, 562), 类型: float32\n    2025-06-26 20:23:07,812 - INFO -   均值: 128.171, 标准差: 69.131\n    2025-06-26 20:23:07,812 - INFO -   范围: [0.000, 255.000]\n    2025-06-26 20:23:07,818 - INFO - 预处理图像已保存\n    2025-06-26 20:23:07,818 - INFO - ==================================================\n    2025-06-26 20:23:07,819 - INFO - 步骤 3: 执行图像配准\n    2025-06-26 20:23:07,819 - INFO - 尝试多种运动模型进行配准...\n    2025-06-26 20:23:07,819 - INFO - 开始 TRANSLATION 配准...\n    2025-06-26 20:23:07,839 - ERROR - TRANSLATION 配准失败: OpenCV(4.10.0) D:\\a\\opencv-python\\opencv-python\\opencv\\modules\\video\\src\\ecc.cpp:589: error: (-7:Iterations do not converge) The algorithm stopped before its convergence. The correlation is going to be minimized. Images may be uncorrelated or non-overlapped in function 'cv::findTransformECC'\n    \n    2025-06-26 20:23:07,839 - INFO - 失败耗时: 0.02秒\n    2025-06-26 20:23:07,840 - INFO - 开始 EUCLIDEAN 配准...\n    2025-06-26 20:23:07,852 - ERROR - EUCLIDEAN 配准失败: OpenCV(4.10.0) D:\\a\\opencv-python\\opencv-python\\opencv\\modules\\video\\src\\ecc.cpp:589: error: (-7:Iterations do not converge) The algorithm stopped before its convergence. The correlation is going to be minimized. Images may be uncorrelated or non-overlapped in function 'cv::findTransformECC'\n    \n    2025-06-26 20:23:07,852 - INFO - 失败耗时: 0.01秒\n    2025-06-26 20:23:07,853 - INFO - 开始 AFFINE 配准...\n    2025-06-26 20:23:07,868 - ERROR - AFFINE 配准失败: OpenCV(4.10.0) D:\\a\\opencv-python\\opencv-python\\opencv\\modules\\video\\src\\ecc.cpp:589: error: (-7:Iterations do not converge) The algorithm stopped before its convergence. The correlation is going to be minimized. Images may be uncorrelated or non-overlapped in function 'cv::findTransformECC'\n    \n    2025-06-26 20:23:07,868 - INFO - 失败耗时: 0.01秒\n    2025-06-26 20:23:07,869 - INFO - 开始 HOMOGRAPHY 配准...\n    2025-06-26 20:23:07,893 - ERROR - HOMOGRAPHY 配准失败: OpenCV(4.10.0) D:\\a\\opencv-python\\opencv-python\\opencv\\modules\\video\\src\\ecc.cpp:589: error: (-7:Iterations do not converge) The algorithm stopped before its convergence. The correlation is going to be minimized. Images may be uncorrelated or non-overlapped in function 'cv::findTransformECC'\n    \n    2025-06-26 20:23:07,894 - INFO - 失败耗时: 0.02秒\n    2025-06-26 20:23:07,894 - ERROR - 所有运动模型配准均失败\n    2025-06-26 20:23:07,894 - ERROR - 所有配准方法均失败\n    \n    ```\n    \n    \n\n**结果与分析：**\n\n尽管我们采用了多种策略并进行了代码增强，当前阶段在所选取的局部图像上实现自动配准的尝试尚未取得成功：\n\n1.  **基于局部特征的配准结果：**\n    *   在两张局部图像中均成功检测到大量 SIFT 特征点（分别为 3544 和 2793 个特征点）。\n    *   初步的描述符匹配识别出 88 对潜在的对应特征。\n    *   然而，在进行几何一致性筛选后，未能找到任何一对符合全局几何变换模型的内点（\"No correspondences found\"）。\n    *   **分析：** 这一结果与我们肉眼观察到的现象吻合——H&E 和荧光图像虽然是同一组织区域，但细胞核在两种染色模态下的微观形态差异显著，导致基于局部纹理的 SIFT 描述符不足以建立可靠的对应关系。即使找到少量描述符相似的特征点，它们在两张图像中的空间分布也缺乏整体的一致性，无法用一个简单的几何变换解释。\n2.  **基于图像强度的配准（ECC）结果：**\n    *   我们系统地尝试了 TRANSLATION, EUCLIDEAN, AFFINE 和 HOMOGRAPHY 四种运动模型进行 ECC 配准。\n    *   遗憾的是，所有尝试均未能收敛到有效的变换矩阵，并报告了 `(-7:Iterations do not converge)` 错误，提示 \"Images may be uncorrelated or non-overlapped\"。\n    *   **分析：** 尽管使用了 H&E 苏木素通道和荧光灰度图（理论上都突出细胞核），并尝试了直方图均衡化和高斯模糊预处理，两张图像之间的像素强度相关性仍然不足以驱动 ECC 算法收敛。这可能的原因包括：\n        *   两张图像的像素强度分布和纹理模式在局部区域差异较大，即使是细胞核，其在 H&E 灰度图和荧光灰度图中的具体像素值变化模式可能差异显著。\n        *   虽然整体形状相似，但如果局部存在复杂的非线性形变，超出了 HOMOGRAPHY 模型的表达能力，ECC 也难以找到合适的变换。\n        *   所选取的局部区域在像素强度层面可能缺乏足够的、在两张图像中都能稳定对应的变化模式。\n\n**下一步计划：**\n\n鉴于自动特征匹配和基于强度的 ECC 方法在当前局部图像上均遭遇困难，但我们观察到两张切片的整体形态是相似的，我们将调整策略，重点探索利用宏观结构信息进行配准：\n\n**探索基于手动标记点的配准 (Manual Landmark-Based Registration)：** 利用我们肉眼识别两张图像中共同宏观结构（如血管分支、组织边界、大的细胞团块边缘等）的能力，在两张图像中手动选取至少四对对应的点。\n\n*   **方法：** 可以借助专业的图像处理软件如 ImageJ/Fiji 或 QuPath 的手动标记点功能，导出对应点的坐标。然后使用这些坐标点，通过 `cv2.findHomography` 或 `cv2.getAffineTransform` 在 Python 中计算变换矩阵。\n*   **优势：** 这种方法不受模态差异导致的微观纹理不匹配影响，直接利用了可靠的宏观对应信息，有望获得更准确的初始对齐。","slug":"cancerAI_1","published":1,"updated":"2025-07-12T13:20:45.703Z","comments":1,"layout":"post","photos":[],"_id":"cmd15y0w60001lstv1jgxc04l","content":"<p><strong>主题：</strong> 多模态数字病理图像（H&amp;E 与多重荧光）配准方法探索进度报告</p>\n<p><strong>任务目标：</strong></p>\n<p>对齐不同染色模态下的小鼠肝脏组织切片图像，具体包括一张来自 3DHISTECH Pannoramic 扫描仪的 H&amp;E 染色图像（.mrsx 格式）与一张多重荧光染色图像（源文件为 .tiff.tiff 格式，包含 7 个通道）。</p>\n<blockquote>\n<p>想象一下，你有两张部分透明的地图，一张是显示城市轮廓和主干道的“地形图”（H&amp;E苏木精通道，主要显示细胞核的形态），另一张是只标注了所有河流位置的“水文图”（DAPI通道，专门标记细胞核DNA）。这两张图描绘的是同一个区域，但因为是分开绘制的，当你把它们叠在一起时，会发现河流并没有恰好流经城市峡谷，而是有所偏移和旋转。</p>\n</blockquote>\n<p>图像配准（Image Registration） 的任务，就是通过电脑自动地移动、旋转、缩放这张“水文图”，直到它与“地形图”上的对应结构完美重合。</p>\n<p>由于涉及全玻片图像（Whole Slide Images, WSI）的<strong>巨大尺寸和专有文件格式</strong>的读取挑战，本阶段的工作重点首先聚焦于在选定的<strong>局部组织区域</strong>内探索并实现有效的配准策略，为后续的全玻片级别配准奠定技术基础。</p>\n<p><strong>研究方法与实施：</strong></p>\n<p>为了规避直接处理复杂 WSI 格式的难题，并控制计算资源，我首先采用数字病理图像处理软件（Imagescope 和 QuPath）提取了两张图像中<strong>高度重叠</strong>的局部区域。具体操作包括：</p>\n<ol>\n<li>从 H&amp;E 图像（.mrsx）中截取一块代表性组织区域，并导出为标准的 <strong>TIFF 格式</strong>图像（HCC0-1-HE-1.png）。</li>\n</ol>\n<p><img src=\"/blog/cancerAI-1-1.png\" alt=\"alt text\"></p>\n<p>2.从多重荧光图像（.tiff.tiff），特别是聚焦于<strong>细胞核染色通道</strong>（根据元数据，该通道包含了与 H&amp;E 苏木素染色相对应的细胞核信息，此处使用了导出后可正常显示的 JPG 格式， HCC0-1-IHC-1.jpg），截取与上述 H&amp;E 区域高度对应的局部图像。</p>\n<p><img src=\"/blog/cancerAI-1-2.png\" alt=\"alt text\"></p>\n<p>这些局部图像被用作后续配准算法的输入。我探索了两种主流的图像配准策略：</p>\n<ol>\n<li><p><strong>基于局部特征的配准 (Feature-Based Registration) 探索：</strong></p>\n<ul>\n<li><p><strong>原理：</strong> 该方法旨在通过识别两张图像中独特的<strong>局部模式</strong>（特征点），计算其特征描述符，然后在描述符空间中寻找最相似的匹配对。理想情况下，这些匹配对对应于两张图像中同一物理位置的结构。通过这些对应点，可以计算出将源图像映射到目标图像的最佳几何变换。</p>\n</li>\n<li><p><strong>Python：</strong></p>\n<ul>\n<li><p>我们编写 Python 代码，利用 OpenCV 库实现基于 SIFT (Scale-Invariant Feature Transform) 特征的配准流程。SIFT 因其对尺度和旋转的不变性，常被用于不同视角或模态的图像配准。</p>\n</li>\n<li><p>首先，对 H&amp;E 局部图像进行颜色解卷积，提取苏木素通道（反映<strong>细胞核分布</strong>）。荧光局部图像被转换为<strong>灰度图</strong>，作为代表细胞核信息的输入。</p>\n<p><img src=\"/blog/cancerAI-1-3.png\" alt=\"alt text\"></p>\n</li>\n<li><p>使用 cv2.SIFT_create 检测两张灰度图像中的关键点，并计算它们的 SIFT 描述符。</p>\n</li>\n<li><p>使用 cv2.BFMatcher (Brute Force Matcher) 结合 KNN 算法在描述符空间中进行匹配，并应用比率测试（Ratio Test）筛选出初步的“好”匹配对。</p>\n</li>\n<li><p>尝试使用 cv2.findHomography 函数结合 RANSAC (Random Sample Consensus) 算法，从筛选后的匹配对中估计一个鲁棒的单应性变换矩阵，同时剔除不符合该模型的“外点”。</p>\n</li>\n<li><p><strong>调试与输出：</strong> 输出显示，两张图像都成功加载（H&amp;E 图像尺寸为 512x535 像素，荧光图像尺寸为 4551x4492 像素）并提取了特征点。经过比率测试后，从上千对潜在匹配中仅筛选出了 <strong>1 对</strong>符合条件的“好”匹配点。由于计算单应性变换<strong>至少需要 4 对对应点</strong>，因此配准过程在估计变换矩阵阶段因缺乏足够的有效输入而直接失败。</p>\n</li>\n</ul>\n<p><img src=\"/blog/cancerAI-1-4.png\" alt=\"alt text\"></p>\n</li>\n<li><p><strong>Fiji ：</strong></p>\n<ul>\n<li><p>考虑到可能是代码实现细节或库版本问题，我们进一步尝试在广泛用于生物医学图像处理的 Fiji (ImageJ) 软件中，使用其成熟的 SIFT 配准插件进行验证。</p>\n</li>\n<li><p>我们按照 Fiji 官方推荐的步骤操作：首先使用 Plugins &gt; Feature Extraction &gt; Extract SIFT Correspondences 提取并匹配 SIFT 特征，然后使用 Plugins &gt; Registration &gt; Linear Stack Alignment with SIFT 应用这些匹配进行线性（通常是仿射）对齐。</p>\n</li>\n<li><p><strong>输出：</strong> Fiji 的 SIFT 插件输出了详细的匹配过程信息，与代码中的观察高度一致：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Processing SIFT ... took 1165ms. 7006 features extracted.</span><br><span class=\"line\">Processing SIFT ... took 148ms. 382 features extracted.</span><br><span class=\"line\">Identifying correspondence candidates using brute force ... took 197ms. 52 potentially corresponding features identified.</span><br><span class=\"line\">Filtering correspondence candidates by geometric consensus ... took 2ms. No correspondences found.</span><br><span class=\"line\">Processing SIFT ... took 1000ms. 7006 features extracted.</span><br><span class=\"line\">Done.</span><br></pre></td></tr></table></figure>\n\n<p>尽管在两张图像中分别提取了 7006 和 382 个特征点，并找到了 52 对潜在匹配，但在进行几何一致性过滤后，<strong>没有找到任何一对有效的对应点（”No correspondences found”）</strong>。</p>\n</li>\n<li><p><strong>分析：</strong> Fiji 作为成熟的图像处理平台，其 SIFT 插件的失败结果进一步有力地证实了基于 SIFT 特征匹配的方法在当前这对 H&amp;E 与荧光局部图像上确实难以奏效。问题根源不在于 SIFT 算法本身或实现细节，而在于两张图像的内在属性——<strong>不同染色模态导致的微观纹理差异过大</strong>，使得 SIFT 描述符不足以捕捉到在不同图像间具有一致几何关系的特征，即使少量描述符相似，其空间位置也无法用一个简单的线性变换（如仿射或单应性）来解释。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>基于图像强度的配准 (Intensity-Based Registration)：</strong></p>\n<ul>\n<li><p><strong>原理：</strong> 与基于特征的方法不同，该方法不依赖于离散的特征点，而是<strong>直接利用图像的像素强度信息</strong>。它通过迭代地调整一个预设的几何变换模型的参数（例如平移、旋转、缩放、透视），寻找能够最大化两张图像（源图像变换后与目标图像）之间相似性度量（如增强相关性系数 ECC）的变换参数。</p>\n<blockquote>\n<p>宏观结构（如组织边界、血管轮廓、大的细胞团块）会在图像中形成显著的像素强度对比和梯度变化区域。如果这些宏观结构在两张图像中都能清晰可见，并且它们形成的强度模式具有一定的相似性，基于强度的算法<strong>可能</strong>能够利用这些信息进行对齐。可以说它<strong>间接</strong>利用了宏观结构，因为它处理的是构成这些结构的像素信息。</p>\n</blockquote>\n</li>\n<li><p><strong>实施：</strong> 我们使用了 OpenCV 库提供的 <code>findTransformECC</code> 函数。为了全面评估该方法在不同形变假设下的性能，我们系统地尝试了多种运动模型，包括：</p>\n<ul>\n<li><code>cv2.MOTION_TRANSLATION</code> (仅平移)</li>\n<li><code>cv2.MOTION_EUCLIDEAN</code> (平移 + 旋转)</li>\n<li><code>cv2.MOTION_AFFINE</code> (平移 + 旋转 + 缩放 + 剪切)</li>\n<li><code>cv2.MOTION_HOMOGRAPHY</code> (仿射 + 透视)</li>\n</ul>\n</li>\n<li><p>输入图像为经过预处理的 H&amp;E 苏木素通道和荧光灰度图。预处理步骤包括直方图均衡化（增强对比度）和高斯模糊（减少噪声），以希望提高算法收敛性。</p>\n</li>\n<li><p>系统性地尝试了 TRANSLATION, EUCLIDEAN, AFFINE, HOMOGRAPHY 四种运动模型，试图探索不同复杂度的形变模型是否能找到有效的对齐。</p>\n</li>\n<li><p><strong>分析</strong>：两张图像在像素强度层面的<strong>局部变化模式</strong>仍然存在显著差异，不足以驱动 ECC 算法通过迭代优化找到有效的对齐。预处理（直方图均衡化、高斯模糊）未能弥合这种根本性的模态差异。</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2025-06-26 20:23:07,716 - INFO - 开始增强的图像配准程序</span><br><span class=\"line\">2025-06-26 20:23:07,717 - INFO - 输出目录: output_patch_registration_enhanced</span><br><span class=\"line\">2025-06-26 20:23:07,717 - INFO - ==================================================</span><br><span class=\"line\">2025-06-26 20:23:07,717 - INFO - 步骤 1: 加载图像</span><br><span class=\"line\">2025-06-26 20:23:07,718 - INFO - 加载 H&amp;E 图像: F:/BaiduNetdiskDownload/HCC0-1/HCC0-1-HE-1.png</span><br><span class=\"line\">2025-06-26 20:23:07,748 - INFO - H&amp;E RGB 统计信息:</span><br><span class=\"line\">2025-06-26 20:23:07,748 - INFO -   形状: (512, 535, 3), 类型: uint8</span><br><span class=\"line\">2025-06-26 20:23:07,748 - INFO -   均值: 204.676, 标准差: 49.826</span><br><span class=\"line\">2025-06-26 20:23:07,749 - INFO -   范围: [0.000, 255.000]</span><br><span class=\"line\">2025-06-26 20:23:07,749 - INFO - 加载荧光图像: F:/BaiduNetdiskDownload/HCC0-1/HCC0-1-IHC-3.jpg</span><br><span class=\"line\">2025-06-26 20:23:07,754 - INFO - 荧光灰度 统计信息:</span><br><span class=\"line\">2025-06-26 20:23:07,754 - INFO -   形状: (569, 562), 类型: uint8</span><br><span class=\"line\">2025-06-26 20:23:07,755 - INFO -   均值: 79.511, 标准差: 62.615</span><br><span class=\"line\">2025-06-26 20:23:07,755 - INFO -   范围: [0.000, 255.000]</span><br><span class=\"line\">2025-06-26 20:23:07,755 - INFO - ==================================================</span><br><span class=\"line\">2025-06-26 20:23:07,756 - INFO - 步骤 2: 图像预处理</span><br><span class=\"line\">2025-06-26 20:23:07,756 - INFO - 开始H&amp;E颜色解卷积处理...</span><br><span class=\"line\">2025-06-26 20:23:07,771 - INFO - 染色矩阵 ruifrok: 苏木素OD范围 [0.000, 0.150]</span><br><span class=\"line\">2025-06-26 20:23:07,780 - INFO - 保存调试图像: output_patch_registration_enhanced\\debug_he_hematoxylin_ruifrok.png</span><br><span class=\"line\">2025-06-26 20:23:07,791 - INFO - 染色矩阵 macenko: 苏木素OD范围 [0.000, 0.154]</span><br><span class=\"line\">2025-06-26 20:23:07,800 - INFO - 保存调试图像: output_patch_registration_enhanced\\debug_he_hematoxylin_macenko.png</span><br><span class=\"line\">2025-06-26 20:23:07,801 - INFO - H&amp;E解卷积完成，返回形状: (512, 535)</span><br><span class=\"line\">2025-06-26 20:23:07,802 - INFO - 应用直方图均衡化</span><br><span class=\"line\">2025-06-26 20:23:07,804 - INFO - 应用高斯模糊，核大小: 3</span><br><span class=\"line\">2025-06-26 20:23:07,806 - INFO - 应用直方图均衡化</span><br><span class=\"line\">2025-06-26 20:23:07,806 - INFO - 应用高斯模糊，核大小: 3</span><br><span class=\"line\">2025-06-26 20:23:07,809 - INFO - 预处理后H&amp;E 统计信息:</span><br><span class=\"line\">2025-06-26 20:23:07,810 - INFO -   形状: (512, 535), 类型: float32</span><br><span class=\"line\">2025-06-26 20:23:07,810 - INFO -   均值: 133.401, 标准差: 71.034</span><br><span class=\"line\">2025-06-26 20:23:07,810 - INFO -   范围: [1.000, 255.000]</span><br><span class=\"line\">2025-06-26 20:23:07,811 - INFO - 预处理后荧光 统计信息:</span><br><span class=\"line\">2025-06-26 20:23:07,811 - INFO -   形状: (569, 562), 类型: float32</span><br><span class=\"line\">2025-06-26 20:23:07,812 - INFO -   均值: 128.171, 标准差: 69.131</span><br><span class=\"line\">2025-06-26 20:23:07,812 - INFO -   范围: [0.000, 255.000]</span><br><span class=\"line\">2025-06-26 20:23:07,818 - INFO - 预处理图像已保存</span><br><span class=\"line\">2025-06-26 20:23:07,818 - INFO - ==================================================</span><br><span class=\"line\">2025-06-26 20:23:07,819 - INFO - 步骤 3: 执行图像配准</span><br><span class=\"line\">2025-06-26 20:23:07,819 - INFO - 尝试多种运动模型进行配准...</span><br><span class=\"line\">2025-06-26 20:23:07,819 - INFO - 开始 TRANSLATION 配准...</span><br><span class=\"line\">2025-06-26 20:23:07,839 - ERROR - TRANSLATION 配准失败: OpenCV(4.10.0) D:\\a\\opencv-python\\opencv-python\\opencv\\modules\\video\\src\\ecc.cpp:589: error: (-7:Iterations do not converge) The algorithm stopped before its convergence. The correlation is going to be minimized. Images may be uncorrelated or non-overlapped in function &#x27;cv::findTransformECC&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">2025-06-26 20:23:07,839 - INFO - 失败耗时: 0.02秒</span><br><span class=\"line\">2025-06-26 20:23:07,840 - INFO - 开始 EUCLIDEAN 配准...</span><br><span class=\"line\">2025-06-26 20:23:07,852 - ERROR - EUCLIDEAN 配准失败: OpenCV(4.10.0) D:\\a\\opencv-python\\opencv-python\\opencv\\modules\\video\\src\\ecc.cpp:589: error: (-7:Iterations do not converge) The algorithm stopped before its convergence. The correlation is going to be minimized. Images may be uncorrelated or non-overlapped in function &#x27;cv::findTransformECC&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">2025-06-26 20:23:07,852 - INFO - 失败耗时: 0.01秒</span><br><span class=\"line\">2025-06-26 20:23:07,853 - INFO - 开始 AFFINE 配准...</span><br><span class=\"line\">2025-06-26 20:23:07,868 - ERROR - AFFINE 配准失败: OpenCV(4.10.0) D:\\a\\opencv-python\\opencv-python\\opencv\\modules\\video\\src\\ecc.cpp:589: error: (-7:Iterations do not converge) The algorithm stopped before its convergence. The correlation is going to be minimized. Images may be uncorrelated or non-overlapped in function &#x27;cv::findTransformECC&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">2025-06-26 20:23:07,868 - INFO - 失败耗时: 0.01秒</span><br><span class=\"line\">2025-06-26 20:23:07,869 - INFO - 开始 HOMOGRAPHY 配准...</span><br><span class=\"line\">2025-06-26 20:23:07,893 - ERROR - HOMOGRAPHY 配准失败: OpenCV(4.10.0) D:\\a\\opencv-python\\opencv-python\\opencv\\modules\\video\\src\\ecc.cpp:589: error: (-7:Iterations do not converge) The algorithm stopped before its convergence. The correlation is going to be minimized. Images may be uncorrelated or non-overlapped in function &#x27;cv::findTransformECC&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">2025-06-26 20:23:07,894 - INFO - 失败耗时: 0.02秒</span><br><span class=\"line\">2025-06-26 20:23:07,894 - ERROR - 所有运动模型配准均失败</span><br><span class=\"line\">2025-06-26 20:23:07,894 - ERROR - 所有配准方法均失败</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><strong>结果与分析：</strong></p>\n<p>尽管我们采用了多种策略并进行了代码增强，当前阶段在所选取的局部图像上实现自动配准的尝试尚未取得成功：</p>\n<ol>\n<li><strong>基于局部特征的配准结果：</strong><ul>\n<li>在两张局部图像中均成功检测到大量 SIFT 特征点（分别为 3544 和 2793 个特征点）。</li>\n<li>初步的描述符匹配识别出 88 对潜在的对应特征。</li>\n<li>然而，在进行几何一致性筛选后，未能找到任何一对符合全局几何变换模型的内点（”No correspondences found”）。</li>\n<li><strong>分析：</strong> 这一结果与我们肉眼观察到的现象吻合——H&amp;E 和荧光图像虽然是同一组织区域，但细胞核在两种染色模态下的微观形态差异显著，导致基于局部纹理的 SIFT 描述符不足以建立可靠的对应关系。即使找到少量描述符相似的特征点，它们在两张图像中的空间分布也缺乏整体的一致性，无法用一个简单的几何变换解释。</li>\n</ul>\n</li>\n<li><strong>基于图像强度的配准（ECC）结果：</strong><ul>\n<li>我们系统地尝试了 TRANSLATION, EUCLIDEAN, AFFINE 和 HOMOGRAPHY 四种运动模型进行 ECC 配准。</li>\n<li>遗憾的是，所有尝试均未能收敛到有效的变换矩阵，并报告了 <code>(-7:Iterations do not converge)</code> 错误，提示 “Images may be uncorrelated or non-overlapped”。</li>\n<li><strong>分析：</strong> 尽管使用了 H&amp;E 苏木素通道和荧光灰度图（理论上都突出细胞核），并尝试了直方图均衡化和高斯模糊预处理，两张图像之间的像素强度相关性仍然不足以驱动 ECC 算法收敛。这可能的原因包括：<ul>\n<li>两张图像的像素强度分布和纹理模式在局部区域差异较大，即使是细胞核，其在 H&amp;E 灰度图和荧光灰度图中的具体像素值变化模式可能差异显著。</li>\n<li>虽然整体形状相似，但如果局部存在复杂的非线性形变，超出了 HOMOGRAPHY 模型的表达能力，ECC 也难以找到合适的变换。</li>\n<li>所选取的局部区域在像素强度层面可能缺乏足够的、在两张图像中都能稳定对应的变化模式。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>下一步计划：</strong></p>\n<p>鉴于自动特征匹配和基于强度的 ECC 方法在当前局部图像上均遭遇困难，但我们观察到两张切片的整体形态是相似的，我们将调整策略，重点探索利用宏观结构信息进行配准：</p>\n<p><strong>探索基于手动标记点的配准 (Manual Landmark-Based Registration)：</strong> 利用我们肉眼识别两张图像中共同宏观结构（如血管分支、组织边界、大的细胞团块边缘等）的能力，在两张图像中手动选取至少四对对应的点。</p>\n<ul>\n<li><strong>方法：</strong> 可以借助专业的图像处理软件如 ImageJ&#x2F;Fiji 或 QuPath 的手动标记点功能，导出对应点的坐标。然后使用这些坐标点，通过 <code>cv2.findHomography</code> 或 <code>cv2.getAffineTransform</code> 在 Python 中计算变换矩阵。</li>\n<li><strong>优势：</strong> 这种方法不受模态差异导致的微观纹理不匹配影响，直接利用了可靠的宏观对应信息，有望获得更准确的初始对齐。</li>\n</ul>\n","length":8179,"excerpt":"","more":"<p><strong>主题：</strong> 多模态数字病理图像（H&amp;E 与多重荧光）配准方法探索进度报告</p>\n<p><strong>任务目标：</strong></p>\n<p>对齐不同染色模态下的小鼠肝脏组织切片图像，具体包括一张来自 3DHISTECH Pannoramic 扫描仪的 H&amp;E 染色图像（.mrsx 格式）与一张多重荧光染色图像（源文件为 .tiff.tiff 格式，包含 7 个通道）。</p>\n<blockquote>\n<p>想象一下，你有两张部分透明的地图，一张是显示城市轮廓和主干道的“地形图”（H&amp;E苏木精通道，主要显示细胞核的形态），另一张是只标注了所有河流位置的“水文图”（DAPI通道，专门标记细胞核DNA）。这两张图描绘的是同一个区域，但因为是分开绘制的，当你把它们叠在一起时，会发现河流并没有恰好流经城市峡谷，而是有所偏移和旋转。</p>\n</blockquote>\n<p>图像配准（Image Registration） 的任务，就是通过电脑自动地移动、旋转、缩放这张“水文图”，直到它与“地形图”上的对应结构完美重合。</p>\n<p>由于涉及全玻片图像（Whole Slide Images, WSI）的<strong>巨大尺寸和专有文件格式</strong>的读取挑战，本阶段的工作重点首先聚焦于在选定的<strong>局部组织区域</strong>内探索并实现有效的配准策略，为后续的全玻片级别配准奠定技术基础。</p>\n<p><strong>研究方法与实施：</strong></p>\n<p>为了规避直接处理复杂 WSI 格式的难题，并控制计算资源，我首先采用数字病理图像处理软件（Imagescope 和 QuPath）提取了两张图像中<strong>高度重叠</strong>的局部区域。具体操作包括：</p>\n<ol>\n<li>从 H&amp;E 图像（.mrsx）中截取一块代表性组织区域，并导出为标准的 <strong>TIFF 格式</strong>图像（HCC0-1-HE-1.png）。</li>\n</ol>\n<p><img src=\"/blog/cancerAI-1-1.png\" alt=\"alt text\"></p>\n<p>2.从多重荧光图像（.tiff.tiff），特别是聚焦于<strong>细胞核染色通道</strong>（根据元数据，该通道包含了与 H&amp;E 苏木素染色相对应的细胞核信息，此处使用了导出后可正常显示的 JPG 格式， HCC0-1-IHC-1.jpg），截取与上述 H&amp;E 区域高度对应的局部图像。</p>\n<p><img src=\"/blog/cancerAI-1-2.png\" alt=\"alt text\"></p>\n<p>这些局部图像被用作后续配准算法的输入。我探索了两种主流的图像配准策略：</p>\n<ol>\n<li><p><strong>基于局部特征的配准 (Feature-Based Registration) 探索：</strong></p>\n<ul>\n<li><p><strong>原理：</strong> 该方法旨在通过识别两张图像中独特的<strong>局部模式</strong>（特征点），计算其特征描述符，然后在描述符空间中寻找最相似的匹配对。理想情况下，这些匹配对对应于两张图像中同一物理位置的结构。通过这些对应点，可以计算出将源图像映射到目标图像的最佳几何变换。</p>\n</li>\n<li><p><strong>Python：</strong></p>\n<ul>\n<li><p>我们编写 Python 代码，利用 OpenCV 库实现基于 SIFT (Scale-Invariant Feature Transform) 特征的配准流程。SIFT 因其对尺度和旋转的不变性，常被用于不同视角或模态的图像配准。</p>\n</li>\n<li><p>首先，对 H&amp;E 局部图像进行颜色解卷积，提取苏木素通道（反映<strong>细胞核分布</strong>）。荧光局部图像被转换为<strong>灰度图</strong>，作为代表细胞核信息的输入。</p>\n<p><img src=\"/blog/cancerAI-1-3.png\" alt=\"alt text\"></p>\n</li>\n<li><p>使用 cv2.SIFT_create 检测两张灰度图像中的关键点，并计算它们的 SIFT 描述符。</p>\n</li>\n<li><p>使用 cv2.BFMatcher (Brute Force Matcher) 结合 KNN 算法在描述符空间中进行匹配，并应用比率测试（Ratio Test）筛选出初步的“好”匹配对。</p>\n</li>\n<li><p>尝试使用 cv2.findHomography 函数结合 RANSAC (Random Sample Consensus) 算法，从筛选后的匹配对中估计一个鲁棒的单应性变换矩阵，同时剔除不符合该模型的“外点”。</p>\n</li>\n<li><p><strong>调试与输出：</strong> 输出显示，两张图像都成功加载（H&amp;E 图像尺寸为 512x535 像素，荧光图像尺寸为 4551x4492 像素）并提取了特征点。经过比率测试后，从上千对潜在匹配中仅筛选出了 <strong>1 对</strong>符合条件的“好”匹配点。由于计算单应性变换<strong>至少需要 4 对对应点</strong>，因此配准过程在估计变换矩阵阶段因缺乏足够的有效输入而直接失败。</p>\n</li>\n</ul>\n<p><img src=\"/blog/cancerAI-1-4.png\" alt=\"alt text\"></p>\n</li>\n<li><p><strong>Fiji ：</strong></p>\n<ul>\n<li><p>考虑到可能是代码实现细节或库版本问题，我们进一步尝试在广泛用于生物医学图像处理的 Fiji (ImageJ) 软件中，使用其成熟的 SIFT 配准插件进行验证。</p>\n</li>\n<li><p>我们按照 Fiji 官方推荐的步骤操作：首先使用 Plugins &gt; Feature Extraction &gt; Extract SIFT Correspondences 提取并匹配 SIFT 特征，然后使用 Plugins &gt; Registration &gt; Linear Stack Alignment with SIFT 应用这些匹配进行线性（通常是仿射）对齐。</p>\n</li>\n<li><p><strong>输出：</strong> Fiji 的 SIFT 插件输出了详细的匹配过程信息，与代码中的观察高度一致：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Processing SIFT ... took 1165ms. 7006 features extracted.</span><br><span class=\"line\">Processing SIFT ... took 148ms. 382 features extracted.</span><br><span class=\"line\">Identifying correspondence candidates using brute force ... took 197ms. 52 potentially corresponding features identified.</span><br><span class=\"line\">Filtering correspondence candidates by geometric consensus ... took 2ms. No correspondences found.</span><br><span class=\"line\">Processing SIFT ... took 1000ms. 7006 features extracted.</span><br><span class=\"line\">Done.</span><br></pre></td></tr></table></figure>\n\n<p>尽管在两张图像中分别提取了 7006 和 382 个特征点，并找到了 52 对潜在匹配，但在进行几何一致性过滤后，<strong>没有找到任何一对有效的对应点（”No correspondences found”）</strong>。</p>\n</li>\n<li><p><strong>分析：</strong> Fiji 作为成熟的图像处理平台，其 SIFT 插件的失败结果进一步有力地证实了基于 SIFT 特征匹配的方法在当前这对 H&amp;E 与荧光局部图像上确实难以奏效。问题根源不在于 SIFT 算法本身或实现细节，而在于两张图像的内在属性——<strong>不同染色模态导致的微观纹理差异过大</strong>，使得 SIFT 描述符不足以捕捉到在不同图像间具有一致几何关系的特征，即使少量描述符相似，其空间位置也无法用一个简单的线性变换（如仿射或单应性）来解释。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>基于图像强度的配准 (Intensity-Based Registration)：</strong></p>\n<ul>\n<li><p><strong>原理：</strong> 与基于特征的方法不同，该方法不依赖于离散的特征点，而是<strong>直接利用图像的像素强度信息</strong>。它通过迭代地调整一个预设的几何变换模型的参数（例如平移、旋转、缩放、透视），寻找能够最大化两张图像（源图像变换后与目标图像）之间相似性度量（如增强相关性系数 ECC）的变换参数。</p>\n<blockquote>\n<p>宏观结构（如组织边界、血管轮廓、大的细胞团块）会在图像中形成显著的像素强度对比和梯度变化区域。如果这些宏观结构在两张图像中都能清晰可见，并且它们形成的强度模式具有一定的相似性，基于强度的算法<strong>可能</strong>能够利用这些信息进行对齐。可以说它<strong>间接</strong>利用了宏观结构，因为它处理的是构成这些结构的像素信息。</p>\n</blockquote>\n</li>\n<li><p><strong>实施：</strong> 我们使用了 OpenCV 库提供的 <code>findTransformECC</code> 函数。为了全面评估该方法在不同形变假设下的性能，我们系统地尝试了多种运动模型，包括：</p>\n<ul>\n<li><code>cv2.MOTION_TRANSLATION</code> (仅平移)</li>\n<li><code>cv2.MOTION_EUCLIDEAN</code> (平移 + 旋转)</li>\n<li><code>cv2.MOTION_AFFINE</code> (平移 + 旋转 + 缩放 + 剪切)</li>\n<li><code>cv2.MOTION_HOMOGRAPHY</code> (仿射 + 透视)</li>\n</ul>\n</li>\n<li><p>输入图像为经过预处理的 H&amp;E 苏木素通道和荧光灰度图。预处理步骤包括直方图均衡化（增强对比度）和高斯模糊（减少噪声），以希望提高算法收敛性。</p>\n</li>\n<li><p>系统性地尝试了 TRANSLATION, EUCLIDEAN, AFFINE, HOMOGRAPHY 四种运动模型，试图探索不同复杂度的形变模型是否能找到有效的对齐。</p>\n</li>\n<li><p><strong>分析</strong>：两张图像在像素强度层面的<strong>局部变化模式</strong>仍然存在显著差异，不足以驱动 ECC 算法通过迭代优化找到有效的对齐。预处理（直方图均衡化、高斯模糊）未能弥合这种根本性的模态差异。</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2025-06-26 20:23:07,716 - INFO - 开始增强的图像配准程序</span><br><span class=\"line\">2025-06-26 20:23:07,717 - INFO - 输出目录: output_patch_registration_enhanced</span><br><span class=\"line\">2025-06-26 20:23:07,717 - INFO - ==================================================</span><br><span class=\"line\">2025-06-26 20:23:07,717 - INFO - 步骤 1: 加载图像</span><br><span class=\"line\">2025-06-26 20:23:07,718 - INFO - 加载 H&amp;E 图像: F:/BaiduNetdiskDownload/HCC0-1/HCC0-1-HE-1.png</span><br><span class=\"line\">2025-06-26 20:23:07,748 - INFO - H&amp;E RGB 统计信息:</span><br><span class=\"line\">2025-06-26 20:23:07,748 - INFO -   形状: (512, 535, 3), 类型: uint8</span><br><span class=\"line\">2025-06-26 20:23:07,748 - INFO -   均值: 204.676, 标准差: 49.826</span><br><span class=\"line\">2025-06-26 20:23:07,749 - INFO -   范围: [0.000, 255.000]</span><br><span class=\"line\">2025-06-26 20:23:07,749 - INFO - 加载荧光图像: F:/BaiduNetdiskDownload/HCC0-1/HCC0-1-IHC-3.jpg</span><br><span class=\"line\">2025-06-26 20:23:07,754 - INFO - 荧光灰度 统计信息:</span><br><span class=\"line\">2025-06-26 20:23:07,754 - INFO -   形状: (569, 562), 类型: uint8</span><br><span class=\"line\">2025-06-26 20:23:07,755 - INFO -   均值: 79.511, 标准差: 62.615</span><br><span class=\"line\">2025-06-26 20:23:07,755 - INFO -   范围: [0.000, 255.000]</span><br><span class=\"line\">2025-06-26 20:23:07,755 - INFO - ==================================================</span><br><span class=\"line\">2025-06-26 20:23:07,756 - INFO - 步骤 2: 图像预处理</span><br><span class=\"line\">2025-06-26 20:23:07,756 - INFO - 开始H&amp;E颜色解卷积处理...</span><br><span class=\"line\">2025-06-26 20:23:07,771 - INFO - 染色矩阵 ruifrok: 苏木素OD范围 [0.000, 0.150]</span><br><span class=\"line\">2025-06-26 20:23:07,780 - INFO - 保存调试图像: output_patch_registration_enhanced\\debug_he_hematoxylin_ruifrok.png</span><br><span class=\"line\">2025-06-26 20:23:07,791 - INFO - 染色矩阵 macenko: 苏木素OD范围 [0.000, 0.154]</span><br><span class=\"line\">2025-06-26 20:23:07,800 - INFO - 保存调试图像: output_patch_registration_enhanced\\debug_he_hematoxylin_macenko.png</span><br><span class=\"line\">2025-06-26 20:23:07,801 - INFO - H&amp;E解卷积完成，返回形状: (512, 535)</span><br><span class=\"line\">2025-06-26 20:23:07,802 - INFO - 应用直方图均衡化</span><br><span class=\"line\">2025-06-26 20:23:07,804 - INFO - 应用高斯模糊，核大小: 3</span><br><span class=\"line\">2025-06-26 20:23:07,806 - INFO - 应用直方图均衡化</span><br><span class=\"line\">2025-06-26 20:23:07,806 - INFO - 应用高斯模糊，核大小: 3</span><br><span class=\"line\">2025-06-26 20:23:07,809 - INFO - 预处理后H&amp;E 统计信息:</span><br><span class=\"line\">2025-06-26 20:23:07,810 - INFO -   形状: (512, 535), 类型: float32</span><br><span class=\"line\">2025-06-26 20:23:07,810 - INFO -   均值: 133.401, 标准差: 71.034</span><br><span class=\"line\">2025-06-26 20:23:07,810 - INFO -   范围: [1.000, 255.000]</span><br><span class=\"line\">2025-06-26 20:23:07,811 - INFO - 预处理后荧光 统计信息:</span><br><span class=\"line\">2025-06-26 20:23:07,811 - INFO -   形状: (569, 562), 类型: float32</span><br><span class=\"line\">2025-06-26 20:23:07,812 - INFO -   均值: 128.171, 标准差: 69.131</span><br><span class=\"line\">2025-06-26 20:23:07,812 - INFO -   范围: [0.000, 255.000]</span><br><span class=\"line\">2025-06-26 20:23:07,818 - INFO - 预处理图像已保存</span><br><span class=\"line\">2025-06-26 20:23:07,818 - INFO - ==================================================</span><br><span class=\"line\">2025-06-26 20:23:07,819 - INFO - 步骤 3: 执行图像配准</span><br><span class=\"line\">2025-06-26 20:23:07,819 - INFO - 尝试多种运动模型进行配准...</span><br><span class=\"line\">2025-06-26 20:23:07,819 - INFO - 开始 TRANSLATION 配准...</span><br><span class=\"line\">2025-06-26 20:23:07,839 - ERROR - TRANSLATION 配准失败: OpenCV(4.10.0) D:\\a\\opencv-python\\opencv-python\\opencv\\modules\\video\\src\\ecc.cpp:589: error: (-7:Iterations do not converge) The algorithm stopped before its convergence. The correlation is going to be minimized. Images may be uncorrelated or non-overlapped in function &#x27;cv::findTransformECC&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">2025-06-26 20:23:07,839 - INFO - 失败耗时: 0.02秒</span><br><span class=\"line\">2025-06-26 20:23:07,840 - INFO - 开始 EUCLIDEAN 配准...</span><br><span class=\"line\">2025-06-26 20:23:07,852 - ERROR - EUCLIDEAN 配准失败: OpenCV(4.10.0) D:\\a\\opencv-python\\opencv-python\\opencv\\modules\\video\\src\\ecc.cpp:589: error: (-7:Iterations do not converge) The algorithm stopped before its convergence. The correlation is going to be minimized. Images may be uncorrelated or non-overlapped in function &#x27;cv::findTransformECC&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">2025-06-26 20:23:07,852 - INFO - 失败耗时: 0.01秒</span><br><span class=\"line\">2025-06-26 20:23:07,853 - INFO - 开始 AFFINE 配准...</span><br><span class=\"line\">2025-06-26 20:23:07,868 - ERROR - AFFINE 配准失败: OpenCV(4.10.0) D:\\a\\opencv-python\\opencv-python\\opencv\\modules\\video\\src\\ecc.cpp:589: error: (-7:Iterations do not converge) The algorithm stopped before its convergence. The correlation is going to be minimized. Images may be uncorrelated or non-overlapped in function &#x27;cv::findTransformECC&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">2025-06-26 20:23:07,868 - INFO - 失败耗时: 0.01秒</span><br><span class=\"line\">2025-06-26 20:23:07,869 - INFO - 开始 HOMOGRAPHY 配准...</span><br><span class=\"line\">2025-06-26 20:23:07,893 - ERROR - HOMOGRAPHY 配准失败: OpenCV(4.10.0) D:\\a\\opencv-python\\opencv-python\\opencv\\modules\\video\\src\\ecc.cpp:589: error: (-7:Iterations do not converge) The algorithm stopped before its convergence. The correlation is going to be minimized. Images may be uncorrelated or non-overlapped in function &#x27;cv::findTransformECC&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">2025-06-26 20:23:07,894 - INFO - 失败耗时: 0.02秒</span><br><span class=\"line\">2025-06-26 20:23:07,894 - ERROR - 所有运动模型配准均失败</span><br><span class=\"line\">2025-06-26 20:23:07,894 - ERROR - 所有配准方法均失败</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><strong>结果与分析：</strong></p>\n<p>尽管我们采用了多种策略并进行了代码增强，当前阶段在所选取的局部图像上实现自动配准的尝试尚未取得成功：</p>\n<ol>\n<li><strong>基于局部特征的配准结果：</strong><ul>\n<li>在两张局部图像中均成功检测到大量 SIFT 特征点（分别为 3544 和 2793 个特征点）。</li>\n<li>初步的描述符匹配识别出 88 对潜在的对应特征。</li>\n<li>然而，在进行几何一致性筛选后，未能找到任何一对符合全局几何变换模型的内点（”No correspondences found”）。</li>\n<li><strong>分析：</strong> 这一结果与我们肉眼观察到的现象吻合——H&amp;E 和荧光图像虽然是同一组织区域，但细胞核在两种染色模态下的微观形态差异显著，导致基于局部纹理的 SIFT 描述符不足以建立可靠的对应关系。即使找到少量描述符相似的特征点，它们在两张图像中的空间分布也缺乏整体的一致性，无法用一个简单的几何变换解释。</li>\n</ul>\n</li>\n<li><strong>基于图像强度的配准（ECC）结果：</strong><ul>\n<li>我们系统地尝试了 TRANSLATION, EUCLIDEAN, AFFINE 和 HOMOGRAPHY 四种运动模型进行 ECC 配准。</li>\n<li>遗憾的是，所有尝试均未能收敛到有效的变换矩阵，并报告了 <code>(-7:Iterations do not converge)</code> 错误，提示 “Images may be uncorrelated or non-overlapped”。</li>\n<li><strong>分析：</strong> 尽管使用了 H&amp;E 苏木素通道和荧光灰度图（理论上都突出细胞核），并尝试了直方图均衡化和高斯模糊预处理，两张图像之间的像素强度相关性仍然不足以驱动 ECC 算法收敛。这可能的原因包括：<ul>\n<li>两张图像的像素强度分布和纹理模式在局部区域差异较大，即使是细胞核，其在 H&amp;E 灰度图和荧光灰度图中的具体像素值变化模式可能差异显著。</li>\n<li>虽然整体形状相似，但如果局部存在复杂的非线性形变，超出了 HOMOGRAPHY 模型的表达能力，ECC 也难以找到合适的变换。</li>\n<li>所选取的局部区域在像素强度层面可能缺乏足够的、在两张图像中都能稳定对应的变化模式。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>下一步计划：</strong></p>\n<p>鉴于自动特征匹配和基于强度的 ECC 方法在当前局部图像上均遭遇困难，但我们观察到两张切片的整体形态是相似的，我们将调整策略，重点探索利用宏观结构信息进行配准：</p>\n<p><strong>探索基于手动标记点的配准 (Manual Landmark-Based Registration)：</strong> 利用我们肉眼识别两张图像中共同宏观结构（如血管分支、组织边界、大的细胞团块边缘等）的能力，在两张图像中手动选取至少四对对应的点。</p>\n<ul>\n<li><strong>方法：</strong> 可以借助专业的图像处理软件如 ImageJ&#x2F;Fiji 或 QuPath 的手动标记点功能，导出对应点的坐标。然后使用这些坐标点，通过 <code>cv2.findHomography</code> 或 <code>cv2.getAffineTransform</code> 在 Python 中计算变换矩阵。</li>\n<li><strong>优势：</strong> 这种方法不受模态差异导致的微观纹理不匹配影响，直接利用了可靠的宏观对应信息，有望获得更准确的初始对齐。</li>\n</ul>\n"},{"title":"day1-react-learning","date":"2025-07-08T02:09:50.000Z","_content":"今天看了rdp-fe这个代码库。先从route文件看起，找到一个页面就寻到这个文件下，然后根据导入一路地查看，一直到把这个页面的内容业务技术等完全搞明白，，\n今天就看了myapp这一个界面的，因为还不熟悉react的框架，就多看了一会，对一些函数，包括前后端的交互也有了更深入的了解。\n1. request：私人助理，帮助处理和后端服务器通信时的杂事：\n    1. 自动添加基础url：如 /app2/base_info/list_by_user，它会自动在前面拼上服务器的域名，如 http://api.example.com。\n    2. 统一的认证处理：它会自动从localstorage中读取token，并把它添加到每个请求头header上，这样后端就可以知道你的身份。\n    3. 统一的错误处理：它可以捕获错误，也可以理解后端自定义的业务错误。\n    4. 统一数据转换：它可以自动处理请求参数的格式（比如转换成json），也可以自动解析从后端返回的json响应。\n2. render：自定义这一列的单元格应该如何显示，比如点名册的年龄一列，如果是大等于18则显示已成年，小于则显示未成年。\n3. record：相当于班级点名册中被点名（渲染到）的那个同学的所有信息（姓名，性别，年龄等等）\n4. 前后端交互逻辑：\n    1. app.ts里面给出了所有的用于前后端交互的api函数fun，export意味着这个函数可以被项目中其他文件调用（但并不关心这个函数的格式是否适合被所有的文件调用）。\n    ![alt text](day1_react_learning-1.png)\n    - 括号里面是接受经2转换后的数据B（注意这里不进行转换，只规定了需要进行传送的数据，具体的转换需要通过2来完成）；\n    - return request<...>(...)指示了从后端期望返回的数据格式C。\n    - ({})里面可能包括请求的后端url，请求方法，以及附加的传给后端的查询参数B。\n    2. 由于1中app.ts里面封装的函数fun并不适合被所有的文件调用，所以在一些特定场景会通过编写一个桥梁函数来实现“翻译”的作用，即把A转换成后端能够看懂的数据格式B。\n    ![alt text](day1_react_learning-2.png)\n5. 箭头函数：\n    - const 函数名 = async(传入的参数) =>{函数体,要用return指定返回值};","source":"_posts/day1-react-learning.md","raw":"---\ntitle: day1-react-learning\ndate: 2025-07-08 10:09:50\ntags: [react, web前端, 实习日记]\n\n---\n今天看了rdp-fe这个代码库。先从route文件看起，找到一个页面就寻到这个文件下，然后根据导入一路地查看，一直到把这个页面的内容业务技术等完全搞明白，，\n今天就看了myapp这一个界面的，因为还不熟悉react的框架，就多看了一会，对一些函数，包括前后端的交互也有了更深入的了解。\n1. request：私人助理，帮助处理和后端服务器通信时的杂事：\n    1. 自动添加基础url：如 /app2/base_info/list_by_user，它会自动在前面拼上服务器的域名，如 http://api.example.com。\n    2. 统一的认证处理：它会自动从localstorage中读取token，并把它添加到每个请求头header上，这样后端就可以知道你的身份。\n    3. 统一的错误处理：它可以捕获错误，也可以理解后端自定义的业务错误。\n    4. 统一数据转换：它可以自动处理请求参数的格式（比如转换成json），也可以自动解析从后端返回的json响应。\n2. render：自定义这一列的单元格应该如何显示，比如点名册的年龄一列，如果是大等于18则显示已成年，小于则显示未成年。\n3. record：相当于班级点名册中被点名（渲染到）的那个同学的所有信息（姓名，性别，年龄等等）\n4. 前后端交互逻辑：\n    1. app.ts里面给出了所有的用于前后端交互的api函数fun，export意味着这个函数可以被项目中其他文件调用（但并不关心这个函数的格式是否适合被所有的文件调用）。\n    ![alt text](day1_react_learning-1.png)\n    - 括号里面是接受经2转换后的数据B（注意这里不进行转换，只规定了需要进行传送的数据，具体的转换需要通过2来完成）；\n    - return request<...>(...)指示了从后端期望返回的数据格式C。\n    - ({})里面可能包括请求的后端url，请求方法，以及附加的传给后端的查询参数B。\n    2. 由于1中app.ts里面封装的函数fun并不适合被所有的文件调用，所以在一些特定场景会通过编写一个桥梁函数来实现“翻译”的作用，即把A转换成后端能够看懂的数据格式B。\n    ![alt text](day1_react_learning-2.png)\n5. 箭头函数：\n    - const 函数名 = async(传入的参数) =>{函数体,要用return指定返回值};","slug":"day1-react-learning","published":1,"updated":"2025-07-12T12:06:45.345Z","comments":1,"layout":"post","photos":[],"_id":"cmd15y0w80002lstv2uk61qsf","content":"<p>今天看了rdp-fe这个代码库。先从route文件看起，找到一个页面就寻到这个文件下，然后根据导入一路地查看，一直到把这个页面的内容业务技术等完全搞明白，，<br>今天就看了myapp这一个界面的，因为还不熟悉react的框架，就多看了一会，对一些函数，包括前后端的交互也有了更深入的了解。</p>\n<ol>\n<li>request：私人助理，帮助处理和后端服务器通信时的杂事：<ol>\n<li>自动添加基础url：如 &#x2F;app2&#x2F;base_info&#x2F;list_by_user，它会自动在前面拼上服务器的域名，如 <a href=\"http://api.example.com./\">http://api.example.com。</a></li>\n<li>统一的认证处理：它会自动从localstorage中读取token，并把它添加到每个请求头header上，这样后端就可以知道你的身份。</li>\n<li>统一的错误处理：它可以捕获错误，也可以理解后端自定义的业务错误。</li>\n<li>统一数据转换：它可以自动处理请求参数的格式（比如转换成json），也可以自动解析从后端返回的json响应。</li>\n</ol>\n</li>\n<li>render：自定义这一列的单元格应该如何显示，比如点名册的年龄一列，如果是大等于18则显示已成年，小于则显示未成年。</li>\n<li>record：相当于班级点名册中被点名（渲染到）的那个同学的所有信息（姓名，性别，年龄等等）</li>\n<li>前后端交互逻辑：<ol>\n<li>app.ts里面给出了所有的用于前后端交互的api函数fun，export意味着这个函数可以被项目中其他文件调用（但并不关心这个函数的格式是否适合被所有的文件调用）。<br> <img src=\"/blog/day1_react_learning-1.png\" alt=\"alt text\"></li>\n</ol>\n<ul>\n<li>括号里面是接受经2转换后的数据B（注意这里不进行转换，只规定了需要进行传送的数据，具体的转换需要通过2来完成）；</li>\n<li>return request&lt;…&gt;(…)指示了从后端期望返回的数据格式C。</li>\n<li>({})里面可能包括请求的后端url，请求方法，以及附加的传给后端的查询参数B。</li>\n</ul>\n<ol start=\"2\">\n<li>由于1中app.ts里面封装的函数fun并不适合被所有的文件调用，所以在一些特定场景会通过编写一个桥梁函数来实现“翻译”的作用，即把A转换成后端能够看懂的数据格式B。<br> <img src=\"/blog/day1_react_learning-2.png\" alt=\"alt text\"></li>\n</ol>\n</li>\n<li>箭头函数：<ul>\n<li>const 函数名 &#x3D; async(传入的参数) &#x3D;&gt;{函数体,要用return指定返回值};</li>\n</ul>\n</li>\n</ol>\n","length":896,"excerpt":"","more":"<p>今天看了rdp-fe这个代码库。先从route文件看起，找到一个页面就寻到这个文件下，然后根据导入一路地查看，一直到把这个页面的内容业务技术等完全搞明白，，<br>今天就看了myapp这一个界面的，因为还不熟悉react的框架，就多看了一会，对一些函数，包括前后端的交互也有了更深入的了解。</p>\n<ol>\n<li>request：私人助理，帮助处理和后端服务器通信时的杂事：<ol>\n<li>自动添加基础url：如 &#x2F;app2&#x2F;base_info&#x2F;list_by_user，它会自动在前面拼上服务器的域名，如 <a href=\"http://api.example.com./\">http://api.example.com。</a></li>\n<li>统一的认证处理：它会自动从localstorage中读取token，并把它添加到每个请求头header上，这样后端就可以知道你的身份。</li>\n<li>统一的错误处理：它可以捕获错误，也可以理解后端自定义的业务错误。</li>\n<li>统一数据转换：它可以自动处理请求参数的格式（比如转换成json），也可以自动解析从后端返回的json响应。</li>\n</ol>\n</li>\n<li>render：自定义这一列的单元格应该如何显示，比如点名册的年龄一列，如果是大等于18则显示已成年，小于则显示未成年。</li>\n<li>record：相当于班级点名册中被点名（渲染到）的那个同学的所有信息（姓名，性别，年龄等等）</li>\n<li>前后端交互逻辑：<ol>\n<li>app.ts里面给出了所有的用于前后端交互的api函数fun，export意味着这个函数可以被项目中其他文件调用（但并不关心这个函数的格式是否适合被所有的文件调用）。<br> <img src=\"/blog/day1_react_learning-1.png\" alt=\"alt text\"></li>\n</ol>\n<ul>\n<li>括号里面是接受经2转换后的数据B（注意这里不进行转换，只规定了需要进行传送的数据，具体的转换需要通过2来完成）；</li>\n<li>return request&lt;…&gt;(…)指示了从后端期望返回的数据格式C。</li>\n<li>({})里面可能包括请求的后端url，请求方法，以及附加的传给后端的查询参数B。</li>\n</ul>\n<ol start=\"2\">\n<li>由于1中app.ts里面封装的函数fun并不适合被所有的文件调用，所以在一些特定场景会通过编写一个桥梁函数来实现“翻译”的作用，即把A转换成后端能够看懂的数据格式B。<br> <img src=\"/blog/day1_react_learning-2.png\" alt=\"alt text\"></li>\n</ol>\n</li>\n<li>箭头函数：<ul>\n<li>const 函数名 &#x3D; async(传入的参数) &#x3D;&gt;{函数体,要用return指定返回值};</li>\n</ul>\n</li>\n</ol>\n"},{"layout":"posts","title":"多模态数字病理图像（H&E 与多重荧光）配准进度报告2","date":"2025-07-12T13:10:55.000Z","_content":"本次的核心目标是，在两张成像原理、颜色、形态截然不同的图像（H&E与荧光）之间，找到一种可靠的自动对齐方法。\n\n**实现方法一：基于稳定解剖结构的特征匹配策略**\n\n1. **特征提取（核心创新点）：**\n\n   - **H&E图像：** 利用胆管腔及背景区域在H&E图像中呈现为**高亮度白色**的特性，通过高阈值二值化，精确提取其轮廓。\n   - **荧光图像：** 利用同一结构在荧光图像中呈现为**无信号黑色**的特性，通过低阈值反向二值化，提取其轮廓。\n\n2. **特征优化：**\n\n   - 使用形态学操作（核大小[kernel_size = 5]去除噪声，并过滤掉面积过小（[min_contour_area = 100]的伪影，保证了特征的纯净度。\n\n3. **执行配准：**\n\n   - 将上述提取并优化后的“特征掩码”作为输入，利用OpenCV的ECC（增强相关系数）算法，该算法对亮度线性变化不敏感，非常适合本场景。\n   - 我系统性地测试了**平移、欧几里得（包含了平移、旋转和等比缩放）、仿射、透视**四种变换模型，并最终根据**相关系数（CC）**指标，选取了最优的变换模型。\n\n   ![alt text](cancerAI-2-1.png)\n\n   - **第一行：特征提取**\n     - **左侧两张 (H&E)**: 显示了从原始H&E图中提取出的白色胆管区域（掩码）。\n     - **右侧两张 (荧光)**: 显示了从原始荧光图中提取出的黑色胆管区域（掩码）。\n   - **第二行：特征增强与叠加**\n     - **左二 (增强特征)**: 展示了经过距离变换和边缘增强后的胆管特征图。这些图像的灰度变化更丰富，纹理更清晰，非常适合ECC算法进行配准。\n     - **右二 (特征叠加)**: 将提取的胆管掩码（红色/绿色）叠加在原始图像上，直观地展示了程序识别的“锚点”位置是否准确。\n   - **第三行：配准结果**\n     - **配准后H&E胆管特征**: 这是将H&E的特征图根据计算出的矩阵进行变换后的样子。\n     - **胆管特征差异图**: 将配准后的H&E特征图与荧光特征图相减得到的差异。图像越黑，说明差异越小，对齐效果越好。\n     - **胆管特征棋盘格对比**: 将两张特征图拼接成棋盘格。如果对齐得好，您应该能看到胆管的结构在方格之间是连续的，没有明显的错位。\n     - **胆管特征叠加效果**: 将两张特征图半透明地叠加在一起。如果对齐完美，它们的轮廓会高度重合，形成一个清晰的融合图像。\n\n#### 核心成果与对后续工作的启发\n\n**核心成果：**\n\n我成功实现了局部图像的**全自动、高精度配准**。最终在`HOMOGRAPHY`（透视）模型下，获得了高达**0.9669**的相关系数（CC），质量评估为“优秀”。我得到了一份精确的**3x3变换矩阵**，它以数学形式描述了将H&E图像精准对齐到荧光图像上所需的全部几何变换（旋转、平移、缩放、透视）。\n\n![alt text](cancerAI-2-2.png)\n- `HOMOGRAPHY`是本次测试中**最复杂、最强大**的2D变换模型。它不仅包含平移、旋转、缩放、剪切（这些`AFFINE`模型也能做到），还能够模拟**透视畸变**——就像我们从一个倾斜的角度看一个矩形，它会变成梯形一样。\n- **为什么是它？** 在所有四个模型中，`HOMOGRAPHY`取得了最高的**相关系数（0.966946）**，尽管只比次优的`AFFINE`模型（0.964276）高出一点点。这说明，在图像中可能存在极其微小的、非线性的形变（例如组织在切片或放置时产生的轻微褶皱或拉伸），而`HOMOGRAPHY`模型凭借其更高的自由度，捕捉到了这种细微的畸变，从而获得了最佳的匹配分数。\n\n------\n\n**实现方式二：基于互信息的图像配准方案**\n我们不直接比较两张图的“颜色”（像素值），因为它们本来就不同。而是采用一种更聪明的策略——**互信息 (Mutual Information)**。\n它巧妙地绕开了不同模态图像像素值无法直接比较的难题，转而从统计学的角度寻找最佳对齐，使得该方法具有广泛的适用性和鲁棒性。\n#### 工作流程\n1. **选择工具:** 使用强大的医学图像处理库 `SimpleITK` 来执行这个任务。\n2. **配置配准参数:** 详细设置配准过程中的每一个环节，包括：\n\n- 用什么标准衡量对齐的好坏？**(Metric - 度量标准)**\n\n- 如何“猜测”移动过程中非整数像素点的值？**(Interpolator - 插值器)**\n\n- 用什么方法去寻找最佳的对齐位置？**(Optimizer - 优化器)**\n\n- 允许对图像进行哪些类型的变换（移动、旋转、缩放）？**(Transform - 变换类型)**\n\n3. **执行与应用:** 启动配准过程，找到最佳变换参数，并将这个变换应用到需要对齐的图像上，生成最终对齐好的图像。\n\n#### 工具库介绍\n1. `SimpleITK`\n- 作用: 这是实现图像配准的核心工具。它是一个专门为处理和分析多维生物医学图像（2D, 3D, 4D）而设计的开源库。\n\n- `SimpleITK` 就像一个装备齐全的**“专业地图对齐工作室”**。它里面不仅有尺子、量角器（用于**测量和变换**），还有一套完整的工作流程和自动化设备（**配准框架**），可以高效、精确地完成地图对齐任务。代码中的 `ImageRegistrationMethod` 就是这个工作室里的核心**自动化设备**。\n\n2. `scikit-image` \n\n- 作用: 一个通用的图像处理库。在配准前后，你可能需要用它进行一些**预处理或后处理**，比如图像裁剪、降噪、格式转换等。\n\n- 如果 SimpleITK 是专业工作室，那 scikit-image 就是一个非常方便的**“多功能工具箱”**。在把地图送进工作室之前，你可能需要用这个工具箱里的剪刀（裁剪）、清洁布（降噪）来整理一下地图。\n\n3. `napari` \n\n- 作用: 一个为科学家设计的、交互式的多维数据可视化工具。在配准任务中，它的作用至关重要：可以非常直观地检查配准前和配准后的效果。你可以将配准前的两张图以不同颜色叠加显示，看到它们是错位的；配准后，再将固定图像和变形后的移动图像叠加显示，检查对齐的精度。\n\n- `napari` 就像一个高精度的“数字灯箱”。你可以把两张地图（图像）作为不同的图层放上去，调节每个图层的透明度，放大缩小，来仔细比对河流和城市峡谷是否真的对齐了。没有它，你只能通过数字来判断效果，非常不直观。\n\n4. `CycleGAN`\n\n- 作用: 这是一种深度学习模型，属于生成对抗网络（GAN）的一种。它可以学习将一种风格的图像转换成另一种风格，例如，将H&E染色的图像“翻译”成看起来像是DAPI染色的图像。\n\n> 如果H&E和DAPI图像的差异巨大，以至于互信息这种统计方法也难以奏效时，可以先用CycleGAN将H&E图像伪染成“伪DAPI”图像。这样，配准任务就从“多模态”（H&E vs DAPI）变成了“单模态”（伪DAPI vs DAPI），难度会大大降低。\n>\n> 假设你的“地形图”是黑白素描风格，而“水文图”是彩色油画风格，差异太大导致对齐困难。CycleGAN 就像一位“艺术风格模仿大师”，可以学习素描和油画的风格，然后帮你把黑白的“地形图”重新绘制成一张彩色油画风格的“地形图”。这样你手里就有了两张风格相似的油画，对齐起来就容易多了。\n\n#### 互信息\n它不关心像素值的绝对大小，而是关心像素值分布的统计依赖性。\n> 想象一下，一个只会说中文的人（代表H&E图像）和一个只会说英语的人（代表DAPI图像）被关在一个房间里。他们无法直接沟通（像素值无法直接比较）。\n> 但是，如果每次房间里出现“苹果”（H&E图像中出现某个特定范围的像素值）时，那个说英语的人总会说出\"Apple\"（DAPI图像中对应位置也出现某个特定范围的像素值）。即使你听不懂\"Apple\"是什么意思，但你观察久了就会发现，“苹果”这个词的出现，可以很好地预测对方会说\"Apple\"这个词。\n\n互信息就衡量的是这种“预测能力”有多强。如果一个信号（H&E的像素值）的出现，能极大地减少另一个信号（DAPI的像素值）的不确定性，那么它们之间的互信息就很高。\n\n```python\nimport SimpleITK as sitk\n\n# 导入图像文件：\n\n# fixed_image: H&E苏木精通道 (作为参考)\n\n# moving_image: DAPI通道 (需要被移动对齐的图像)\n\n\n\n# 1. 实例化配准方法\n\nregistration_method = sitk.ImageRegistrationMethod()\n\n\n\n# 2. 设置度量标准 (Metric) - Mattes Mutual Information\n\nregistration_method.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)//将图像的连续像素值0~255分成50个桶。通过统计两个图像中来自不同的“桶”的像素对出现的频率来计算互信息。\n\nregistration_method.SetMetricSamplingStrategy(registration_method.RANDOM)//随机采样部分像素来计算，可节省计算资源\n\nregistration_method.SetMetricSamplingPercentage(0.01)\n\n\n\n# 3. 设置插值器 (Interpolator)\n\nregistration_method.SetInterpolator(sitk.sitkLinear)\n//当我们对图像进行旋转缩放时，它的原始像素点的位置会发生变化。通过线性插值可以合理地猜测出这个新的位置应该时什么像素值。\n\n\n# 4. 设置优化器 (Optimizer)\n\nregistration_methodSetOptimizerAsRegularStepGradientDescent(learningRate=1.0, minStep=0.001, numberOfIterations=200)\n\n\n\n# 5. 设置变换类型 (Transform) - 从简单的刚性或仿射变换开始\n\n# initial_transform = sitk.CenteredTransformInitializer(fixed_image, \n\n#                                                       moving_image, \n\n#                                                       sitk.Euler2DTransform(), \n\n#                                                       sitk.CenteredTransformInitializerFilter.GEOMETRY)\n\n# registration_method.SetInitialTransform(initial_transform)\n\n\n\nfinal_transform = sitk.Similarity2DTransform() # 仿射变换的一种\n\nregistration_method.SetInitialTransform(final_transform)\n\n\n\n# 6. 执行配准\n\nfinal_transform = registration_method.Execute(fixed_image, moving_image)\n\n\n\nprint(f\"Final Transform: {final_transform}\")\n\nprint(f\"Optimizer stop condition: {registration_method.GetOptimizerStopConditionDescription()}\")\n\n\n\n# 7. 应用变换\n\nresampler = sitk.ResampleImageFilter()\n\nresampler.SetReferenceImage(fixed_image)\n\nresampler.SetInterpolator(sitk.sitkLinear)\n\nresampler.SetTransform(final_transform)\n\n\n\nwarped_moving_image = resampler.Execute(moving_image)\n```","source":"_posts/cancerAI-2.md","raw":"---\nlayout: posts\ntitle: 多模态数字病理图像（H&E 与多重荧光）配准进度报告2\ndate: 2025-07-12 21:10:55\ntags: [深度学习, AI医学]\n---\n本次的核心目标是，在两张成像原理、颜色、形态截然不同的图像（H&E与荧光）之间，找到一种可靠的自动对齐方法。\n\n**实现方法一：基于稳定解剖结构的特征匹配策略**\n\n1. **特征提取（核心创新点）：**\n\n   - **H&E图像：** 利用胆管腔及背景区域在H&E图像中呈现为**高亮度白色**的特性，通过高阈值二值化，精确提取其轮廓。\n   - **荧光图像：** 利用同一结构在荧光图像中呈现为**无信号黑色**的特性，通过低阈值反向二值化，提取其轮廓。\n\n2. **特征优化：**\n\n   - 使用形态学操作（核大小[kernel_size = 5]去除噪声，并过滤掉面积过小（[min_contour_area = 100]的伪影，保证了特征的纯净度。\n\n3. **执行配准：**\n\n   - 将上述提取并优化后的“特征掩码”作为输入，利用OpenCV的ECC（增强相关系数）算法，该算法对亮度线性变化不敏感，非常适合本场景。\n   - 我系统性地测试了**平移、欧几里得（包含了平移、旋转和等比缩放）、仿射、透视**四种变换模型，并最终根据**相关系数（CC）**指标，选取了最优的变换模型。\n\n   ![alt text](cancerAI-2-1.png)\n\n   - **第一行：特征提取**\n     - **左侧两张 (H&E)**: 显示了从原始H&E图中提取出的白色胆管区域（掩码）。\n     - **右侧两张 (荧光)**: 显示了从原始荧光图中提取出的黑色胆管区域（掩码）。\n   - **第二行：特征增强与叠加**\n     - **左二 (增强特征)**: 展示了经过距离变换和边缘增强后的胆管特征图。这些图像的灰度变化更丰富，纹理更清晰，非常适合ECC算法进行配准。\n     - **右二 (特征叠加)**: 将提取的胆管掩码（红色/绿色）叠加在原始图像上，直观地展示了程序识别的“锚点”位置是否准确。\n   - **第三行：配准结果**\n     - **配准后H&E胆管特征**: 这是将H&E的特征图根据计算出的矩阵进行变换后的样子。\n     - **胆管特征差异图**: 将配准后的H&E特征图与荧光特征图相减得到的差异。图像越黑，说明差异越小，对齐效果越好。\n     - **胆管特征棋盘格对比**: 将两张特征图拼接成棋盘格。如果对齐得好，您应该能看到胆管的结构在方格之间是连续的，没有明显的错位。\n     - **胆管特征叠加效果**: 将两张特征图半透明地叠加在一起。如果对齐完美，它们的轮廓会高度重合，形成一个清晰的融合图像。\n\n#### 核心成果与对后续工作的启发\n\n**核心成果：**\n\n我成功实现了局部图像的**全自动、高精度配准**。最终在`HOMOGRAPHY`（透视）模型下，获得了高达**0.9669**的相关系数（CC），质量评估为“优秀”。我得到了一份精确的**3x3变换矩阵**，它以数学形式描述了将H&E图像精准对齐到荧光图像上所需的全部几何变换（旋转、平移、缩放、透视）。\n\n![alt text](cancerAI-2-2.png)\n- `HOMOGRAPHY`是本次测试中**最复杂、最强大**的2D变换模型。它不仅包含平移、旋转、缩放、剪切（这些`AFFINE`模型也能做到），还能够模拟**透视畸变**——就像我们从一个倾斜的角度看一个矩形，它会变成梯形一样。\n- **为什么是它？** 在所有四个模型中，`HOMOGRAPHY`取得了最高的**相关系数（0.966946）**，尽管只比次优的`AFFINE`模型（0.964276）高出一点点。这说明，在图像中可能存在极其微小的、非线性的形变（例如组织在切片或放置时产生的轻微褶皱或拉伸），而`HOMOGRAPHY`模型凭借其更高的自由度，捕捉到了这种细微的畸变，从而获得了最佳的匹配分数。\n\n------\n\n**实现方式二：基于互信息的图像配准方案**\n我们不直接比较两张图的“颜色”（像素值），因为它们本来就不同。而是采用一种更聪明的策略——**互信息 (Mutual Information)**。\n它巧妙地绕开了不同模态图像像素值无法直接比较的难题，转而从统计学的角度寻找最佳对齐，使得该方法具有广泛的适用性和鲁棒性。\n#### 工作流程\n1. **选择工具:** 使用强大的医学图像处理库 `SimpleITK` 来执行这个任务。\n2. **配置配准参数:** 详细设置配准过程中的每一个环节，包括：\n\n- 用什么标准衡量对齐的好坏？**(Metric - 度量标准)**\n\n- 如何“猜测”移动过程中非整数像素点的值？**(Interpolator - 插值器)**\n\n- 用什么方法去寻找最佳的对齐位置？**(Optimizer - 优化器)**\n\n- 允许对图像进行哪些类型的变换（移动、旋转、缩放）？**(Transform - 变换类型)**\n\n3. **执行与应用:** 启动配准过程，找到最佳变换参数，并将这个变换应用到需要对齐的图像上，生成最终对齐好的图像。\n\n#### 工具库介绍\n1. `SimpleITK`\n- 作用: 这是实现图像配准的核心工具。它是一个专门为处理和分析多维生物医学图像（2D, 3D, 4D）而设计的开源库。\n\n- `SimpleITK` 就像一个装备齐全的**“专业地图对齐工作室”**。它里面不仅有尺子、量角器（用于**测量和变换**），还有一套完整的工作流程和自动化设备（**配准框架**），可以高效、精确地完成地图对齐任务。代码中的 `ImageRegistrationMethod` 就是这个工作室里的核心**自动化设备**。\n\n2. `scikit-image` \n\n- 作用: 一个通用的图像处理库。在配准前后，你可能需要用它进行一些**预处理或后处理**，比如图像裁剪、降噪、格式转换等。\n\n- 如果 SimpleITK 是专业工作室，那 scikit-image 就是一个非常方便的**“多功能工具箱”**。在把地图送进工作室之前，你可能需要用这个工具箱里的剪刀（裁剪）、清洁布（降噪）来整理一下地图。\n\n3. `napari` \n\n- 作用: 一个为科学家设计的、交互式的多维数据可视化工具。在配准任务中，它的作用至关重要：可以非常直观地检查配准前和配准后的效果。你可以将配准前的两张图以不同颜色叠加显示，看到它们是错位的；配准后，再将固定图像和变形后的移动图像叠加显示，检查对齐的精度。\n\n- `napari` 就像一个高精度的“数字灯箱”。你可以把两张地图（图像）作为不同的图层放上去，调节每个图层的透明度，放大缩小，来仔细比对河流和城市峡谷是否真的对齐了。没有它，你只能通过数字来判断效果，非常不直观。\n\n4. `CycleGAN`\n\n- 作用: 这是一种深度学习模型，属于生成对抗网络（GAN）的一种。它可以学习将一种风格的图像转换成另一种风格，例如，将H&E染色的图像“翻译”成看起来像是DAPI染色的图像。\n\n> 如果H&E和DAPI图像的差异巨大，以至于互信息这种统计方法也难以奏效时，可以先用CycleGAN将H&E图像伪染成“伪DAPI”图像。这样，配准任务就从“多模态”（H&E vs DAPI）变成了“单模态”（伪DAPI vs DAPI），难度会大大降低。\n>\n> 假设你的“地形图”是黑白素描风格，而“水文图”是彩色油画风格，差异太大导致对齐困难。CycleGAN 就像一位“艺术风格模仿大师”，可以学习素描和油画的风格，然后帮你把黑白的“地形图”重新绘制成一张彩色油画风格的“地形图”。这样你手里就有了两张风格相似的油画，对齐起来就容易多了。\n\n#### 互信息\n它不关心像素值的绝对大小，而是关心像素值分布的统计依赖性。\n> 想象一下，一个只会说中文的人（代表H&E图像）和一个只会说英语的人（代表DAPI图像）被关在一个房间里。他们无法直接沟通（像素值无法直接比较）。\n> 但是，如果每次房间里出现“苹果”（H&E图像中出现某个特定范围的像素值）时，那个说英语的人总会说出\"Apple\"（DAPI图像中对应位置也出现某个特定范围的像素值）。即使你听不懂\"Apple\"是什么意思，但你观察久了就会发现，“苹果”这个词的出现，可以很好地预测对方会说\"Apple\"这个词。\n\n互信息就衡量的是这种“预测能力”有多强。如果一个信号（H&E的像素值）的出现，能极大地减少另一个信号（DAPI的像素值）的不确定性，那么它们之间的互信息就很高。\n\n```python\nimport SimpleITK as sitk\n\n# 导入图像文件：\n\n# fixed_image: H&E苏木精通道 (作为参考)\n\n# moving_image: DAPI通道 (需要被移动对齐的图像)\n\n\n\n# 1. 实例化配准方法\n\nregistration_method = sitk.ImageRegistrationMethod()\n\n\n\n# 2. 设置度量标准 (Metric) - Mattes Mutual Information\n\nregistration_method.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)//将图像的连续像素值0~255分成50个桶。通过统计两个图像中来自不同的“桶”的像素对出现的频率来计算互信息。\n\nregistration_method.SetMetricSamplingStrategy(registration_method.RANDOM)//随机采样部分像素来计算，可节省计算资源\n\nregistration_method.SetMetricSamplingPercentage(0.01)\n\n\n\n# 3. 设置插值器 (Interpolator)\n\nregistration_method.SetInterpolator(sitk.sitkLinear)\n//当我们对图像进行旋转缩放时，它的原始像素点的位置会发生变化。通过线性插值可以合理地猜测出这个新的位置应该时什么像素值。\n\n\n# 4. 设置优化器 (Optimizer)\n\nregistration_methodSetOptimizerAsRegularStepGradientDescent(learningRate=1.0, minStep=0.001, numberOfIterations=200)\n\n\n\n# 5. 设置变换类型 (Transform) - 从简单的刚性或仿射变换开始\n\n# initial_transform = sitk.CenteredTransformInitializer(fixed_image, \n\n#                                                       moving_image, \n\n#                                                       sitk.Euler2DTransform(), \n\n#                                                       sitk.CenteredTransformInitializerFilter.GEOMETRY)\n\n# registration_method.SetInitialTransform(initial_transform)\n\n\n\nfinal_transform = sitk.Similarity2DTransform() # 仿射变换的一种\n\nregistration_method.SetInitialTransform(final_transform)\n\n\n\n# 6. 执行配准\n\nfinal_transform = registration_method.Execute(fixed_image, moving_image)\n\n\n\nprint(f\"Final Transform: {final_transform}\")\n\nprint(f\"Optimizer stop condition: {registration_method.GetOptimizerStopConditionDescription()}\")\n\n\n\n# 7. 应用变换\n\nresampler = sitk.ResampleImageFilter()\n\nresampler.SetReferenceImage(fixed_image)\n\nresampler.SetInterpolator(sitk.sitkLinear)\n\nresampler.SetTransform(final_transform)\n\n\n\nwarped_moving_image = resampler.Execute(moving_image)\n```","slug":"cancerAI-2","published":1,"updated":"2025-07-13T04:16:05.143Z","comments":1,"photos":[],"_id":"cmd15y0wb0004lstv7ouu401j","content":"<p>本次的核心目标是，在两张成像原理、颜色、形态截然不同的图像（H&amp;E与荧光）之间，找到一种可靠的自动对齐方法。</p>\n<p><strong>实现方法一：基于稳定解剖结构的特征匹配策略</strong></p>\n<ol>\n<li><p><strong>特征提取（核心创新点）：</strong></p>\n<ul>\n<li><strong>H&amp;E图像：</strong> 利用胆管腔及背景区域在H&amp;E图像中呈现为<strong>高亮度白色</strong>的特性，通过高阈值二值化，精确提取其轮廓。</li>\n<li><strong>荧光图像：</strong> 利用同一结构在荧光图像中呈现为<strong>无信号黑色</strong>的特性，通过低阈值反向二值化，提取其轮廓。</li>\n</ul>\n</li>\n<li><p><strong>特征优化：</strong></p>\n<ul>\n<li>使用形态学操作（核大小[kernel_size &#x3D; 5]去除噪声，并过滤掉面积过小（[min_contour_area &#x3D; 100]的伪影，保证了特征的纯净度。</li>\n</ul>\n</li>\n<li><p><strong>执行配准：</strong></p>\n<ul>\n<li>将上述提取并优化后的“特征掩码”作为输入，利用OpenCV的ECC（增强相关系数）算法，该算法对亮度线性变化不敏感，非常适合本场景。</li>\n<li>我系统性地测试了<strong>平移、欧几里得（包含了平移、旋转和等比缩放）、仿射、透视</strong>四种变换模型，并最终根据<strong>相关系数（CC）</strong>指标，选取了最优的变换模型。</li>\n</ul>\n<p><img src=\"/blog/cancerAI-2-1.png\" alt=\"alt text\"></p>\n<ul>\n<li><strong>第一行：特征提取</strong><ul>\n<li><strong>左侧两张 (H&amp;E)</strong>: 显示了从原始H&amp;E图中提取出的白色胆管区域（掩码）。</li>\n<li><strong>右侧两张 (荧光)</strong>: 显示了从原始荧光图中提取出的黑色胆管区域（掩码）。</li>\n</ul>\n</li>\n<li><strong>第二行：特征增强与叠加</strong><ul>\n<li><strong>左二 (增强特征)</strong>: 展示了经过距离变换和边缘增强后的胆管特征图。这些图像的灰度变化更丰富，纹理更清晰，非常适合ECC算法进行配准。</li>\n<li><strong>右二 (特征叠加)</strong>: 将提取的胆管掩码（红色&#x2F;绿色）叠加在原始图像上，直观地展示了程序识别的“锚点”位置是否准确。</li>\n</ul>\n</li>\n<li><strong>第三行：配准结果</strong><ul>\n<li><strong>配准后H&amp;E胆管特征</strong>: 这是将H&amp;E的特征图根据计算出的矩阵进行变换后的样子。</li>\n<li><strong>胆管特征差异图</strong>: 将配准后的H&amp;E特征图与荧光特征图相减得到的差异。图像越黑，说明差异越小，对齐效果越好。</li>\n<li><strong>胆管特征棋盘格对比</strong>: 将两张特征图拼接成棋盘格。如果对齐得好，您应该能看到胆管的结构在方格之间是连续的，没有明显的错位。</li>\n<li><strong>胆管特征叠加效果</strong>: 将两张特征图半透明地叠加在一起。如果对齐完美，它们的轮廓会高度重合，形成一个清晰的融合图像。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"核心成果与对后续工作的启发\"><a href=\"#核心成果与对后续工作的启发\" class=\"headerlink\" title=\"核心成果与对后续工作的启发\"></a>核心成果与对后续工作的启发</h4><p><strong>核心成果：</strong></p>\n<p>我成功实现了局部图像的<strong>全自动、高精度配准</strong>。最终在<code>HOMOGRAPHY</code>（透视）模型下，获得了高达<strong>0.9669</strong>的相关系数（CC），质量评估为“优秀”。我得到了一份精确的<strong>3x3变换矩阵</strong>，它以数学形式描述了将H&amp;E图像精准对齐到荧光图像上所需的全部几何变换（旋转、平移、缩放、透视）。</p>\n<p><img src=\"/blog/cancerAI-2-2.png\" alt=\"alt text\"></p>\n<ul>\n<li><code>HOMOGRAPHY</code>是本次测试中<strong>最复杂、最强大</strong>的2D变换模型。它不仅包含平移、旋转、缩放、剪切（这些<code>AFFINE</code>模型也能做到），还能够模拟<strong>透视畸变</strong>——就像我们从一个倾斜的角度看一个矩形，它会变成梯形一样。</li>\n<li><strong>为什么是它？</strong> 在所有四个模型中，<code>HOMOGRAPHY</code>取得了最高的<strong>相关系数（0.966946）</strong>，尽管只比次优的<code>AFFINE</code>模型（0.964276）高出一点点。这说明，在图像中可能存在极其微小的、非线性的形变（例如组织在切片或放置时产生的轻微褶皱或拉伸），而<code>HOMOGRAPHY</code>模型凭借其更高的自由度，捕捉到了这种细微的畸变，从而获得了最佳的匹配分数。</li>\n</ul>\n<hr>\n<p><strong>实现方式二：基于互信息的图像配准方案</strong><br>我们不直接比较两张图的“颜色”（像素值），因为它们本来就不同。而是采用一种更聪明的策略——**互信息 (Mutual Information)**。<br>它巧妙地绕开了不同模态图像像素值无法直接比较的难题，转而从统计学的角度寻找最佳对齐，使得该方法具有广泛的适用性和鲁棒性。</p>\n<h4 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h4><ol>\n<li><strong>选择工具:</strong> 使用强大的医学图像处理库 <code>SimpleITK</code> 来执行这个任务。</li>\n<li><strong>配置配准参数:</strong> 详细设置配准过程中的每一个环节，包括：</li>\n</ol>\n<ul>\n<li><p>用什么标准衡量对齐的好坏？**(Metric - 度量标准)**</p>\n</li>\n<li><p>如何“猜测”移动过程中非整数像素点的值？**(Interpolator - 插值器)**</p>\n</li>\n<li><p>用什么方法去寻找最佳的对齐位置？**(Optimizer - 优化器)**</p>\n</li>\n<li><p>允许对图像进行哪些类型的变换（移动、旋转、缩放）？**(Transform - 变换类型)**</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>执行与应用:</strong> 启动配准过程，找到最佳变换参数，并将这个变换应用到需要对齐的图像上，生成最终对齐好的图像。</li>\n</ol>\n<h4 id=\"工具库介绍\"><a href=\"#工具库介绍\" class=\"headerlink\" title=\"工具库介绍\"></a>工具库介绍</h4><ol>\n<li><code>SimpleITK</code></li>\n</ol>\n<ul>\n<li><p>作用: 这是实现图像配准的核心工具。它是一个专门为处理和分析多维生物医学图像（2D, 3D, 4D）而设计的开源库。</p>\n</li>\n<li><p><code>SimpleITK</code> 就像一个装备齐全的<strong>“专业地图对齐工作室”</strong>。它里面不仅有尺子、量角器（用于<strong>测量和变换</strong>），还有一套完整的工作流程和自动化设备（<strong>配准框架</strong>），可以高效、精确地完成地图对齐任务。代码中的 <code>ImageRegistrationMethod</code> 就是这个工作室里的核心<strong>自动化设备</strong>。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><code>scikit-image</code></li>\n</ol>\n<ul>\n<li><p>作用: 一个通用的图像处理库。在配准前后，你可能需要用它进行一些<strong>预处理或后处理</strong>，比如图像裁剪、降噪、格式转换等。</p>\n</li>\n<li><p>如果 SimpleITK 是专业工作室，那 scikit-image 就是一个非常方便的<strong>“多功能工具箱”</strong>。在把地图送进工作室之前，你可能需要用这个工具箱里的剪刀（裁剪）、清洁布（降噪）来整理一下地图。</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><code>napari</code></li>\n</ol>\n<ul>\n<li><p>作用: 一个为科学家设计的、交互式的多维数据可视化工具。在配准任务中，它的作用至关重要：可以非常直观地检查配准前和配准后的效果。你可以将配准前的两张图以不同颜色叠加显示，看到它们是错位的；配准后，再将固定图像和变形后的移动图像叠加显示，检查对齐的精度。</p>\n</li>\n<li><p><code>napari</code> 就像一个高精度的“数字灯箱”。你可以把两张地图（图像）作为不同的图层放上去，调节每个图层的透明度，放大缩小，来仔细比对河流和城市峡谷是否真的对齐了。没有它，你只能通过数字来判断效果，非常不直观。</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li><code>CycleGAN</code></li>\n</ol>\n<ul>\n<li>作用: 这是一种深度学习模型，属于生成对抗网络（GAN）的一种。它可以学习将一种风格的图像转换成另一种风格，例如，将H&amp;E染色的图像“翻译”成看起来像是DAPI染色的图像。</li>\n</ul>\n<blockquote>\n<p>如果H&amp;E和DAPI图像的差异巨大，以至于互信息这种统计方法也难以奏效时，可以先用CycleGAN将H&amp;E图像伪染成“伪DAPI”图像。这样，配准任务就从“多模态”（H&amp;E vs DAPI）变成了“单模态”（伪DAPI vs DAPI），难度会大大降低。</p>\n<p>假设你的“地形图”是黑白素描风格，而“水文图”是彩色油画风格，差异太大导致对齐困难。CycleGAN 就像一位“艺术风格模仿大师”，可以学习素描和油画的风格，然后帮你把黑白的“地形图”重新绘制成一张彩色油画风格的“地形图”。这样你手里就有了两张风格相似的油画，对齐起来就容易多了。</p>\n</blockquote>\n<h4 id=\"互信息\"><a href=\"#互信息\" class=\"headerlink\" title=\"互信息\"></a>互信息</h4><p>它不关心像素值的绝对大小，而是关心像素值分布的统计依赖性。</p>\n<blockquote>\n<p>想象一下，一个只会说中文的人（代表H&amp;E图像）和一个只会说英语的人（代表DAPI图像）被关在一个房间里。他们无法直接沟通（像素值无法直接比较）。<br>但是，如果每次房间里出现“苹果”（H&amp;E图像中出现某个特定范围的像素值）时，那个说英语的人总会说出”Apple”（DAPI图像中对应位置也出现某个特定范围的像素值）。即使你听不懂”Apple”是什么意思，但你观察久了就会发现，“苹果”这个词的出现，可以很好地预测对方会说”Apple”这个词。</p>\n</blockquote>\n<p>互信息就衡量的是这种“预测能力”有多强。如果一个信号（H&amp;E的像素值）的出现，能极大地减少另一个信号（DAPI的像素值）的不确定性，那么它们之间的互信息就很高。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> SimpleITK <span class=\"keyword\">as</span> sitk</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 导入图像文件：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># fixed_image: H&amp;E苏木精通道 (作为参考)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># moving_image: DAPI通道 (需要被移动对齐的图像)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1. 实例化配准方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">registration_method = sitk.ImageRegistrationMethod()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 设置度量标准 (Metric) - Mattes Mutual Information</span></span><br><span class=\"line\"></span><br><span class=\"line\">registration_method.SetMetricAsMattesMutualInformation(numberOfHistogramBins=<span class=\"number\">50</span>)//将图像的连续像素值<span class=\"number\">0</span>~<span class=\"number\">255</span>分成<span class=\"number\">50</span>个桶。通过统计两个图像中来自不同的“桶”的像素对出现的频率来计算互信息。</span><br><span class=\"line\"></span><br><span class=\"line\">registration_method.SetMetricSamplingStrategy(registration_method.RANDOM)//随机采样部分像素来计算，可节省计算资源</span><br><span class=\"line\"></span><br><span class=\"line\">registration_method.SetMetricSamplingPercentage(<span class=\"number\">0.01</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 设置插值器 (Interpolator)</span></span><br><span class=\"line\"></span><br><span class=\"line\">registration_method.SetInterpolator(sitk.sitkLinear)</span><br><span class=\"line\">//当我们对图像进行旋转缩放时，它的原始像素点的位置会发生变化。通过线性插值可以合理地猜测出这个新的位置应该时什么像素值。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 设置优化器 (Optimizer)</span></span><br><span class=\"line\"></span><br><span class=\"line\">registration_methodSetOptimizerAsRegularStepGradientDescent(learningRate=<span class=\"number\">1.0</span>, minStep=<span class=\"number\">0.001</span>, numberOfIterations=<span class=\"number\">200</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 设置变换类型 (Transform) - 从简单的刚性或仿射变换开始</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># initial_transform = sitk.CenteredTransformInitializer(fixed_image, </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#                                                       moving_image, </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#                                                       sitk.Euler2DTransform(), </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#                                                       sitk.CenteredTransformInitializerFilter.GEOMETRY)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># registration_method.SetInitialTransform(initial_transform)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">final_transform = sitk.Similarity2DTransform() <span class=\"comment\"># 仿射变换的一种</span></span><br><span class=\"line\"></span><br><span class=\"line\">registration_method.SetInitialTransform(final_transform)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 6. 执行配准</span></span><br><span class=\"line\"></span><br><span class=\"line\">final_transform = registration_method.Execute(fixed_image, moving_image)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Final Transform: <span class=\"subst\">&#123;final_transform&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Optimizer stop condition: <span class=\"subst\">&#123;registration_method.GetOptimizerStopConditionDescription()&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 7. 应用变换</span></span><br><span class=\"line\"></span><br><span class=\"line\">resampler = sitk.ResampleImageFilter()</span><br><span class=\"line\"></span><br><span class=\"line\">resampler.SetReferenceImage(fixed_image)</span><br><span class=\"line\"></span><br><span class=\"line\">resampler.SetInterpolator(sitk.sitkLinear)</span><br><span class=\"line\"></span><br><span class=\"line\">resampler.SetTransform(final_transform)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">warped_moving_image = resampler.Execute(moving_image)</span><br></pre></td></tr></table></figure>","length":4764,"excerpt":"","more":"<p>本次的核心目标是，在两张成像原理、颜色、形态截然不同的图像（H&amp;E与荧光）之间，找到一种可靠的自动对齐方法。</p>\n<p><strong>实现方法一：基于稳定解剖结构的特征匹配策略</strong></p>\n<ol>\n<li><p><strong>特征提取（核心创新点）：</strong></p>\n<ul>\n<li><strong>H&amp;E图像：</strong> 利用胆管腔及背景区域在H&amp;E图像中呈现为<strong>高亮度白色</strong>的特性，通过高阈值二值化，精确提取其轮廓。</li>\n<li><strong>荧光图像：</strong> 利用同一结构在荧光图像中呈现为<strong>无信号黑色</strong>的特性，通过低阈值反向二值化，提取其轮廓。</li>\n</ul>\n</li>\n<li><p><strong>特征优化：</strong></p>\n<ul>\n<li>使用形态学操作（核大小[kernel_size &#x3D; 5]去除噪声，并过滤掉面积过小（[min_contour_area &#x3D; 100]的伪影，保证了特征的纯净度。</li>\n</ul>\n</li>\n<li><p><strong>执行配准：</strong></p>\n<ul>\n<li>将上述提取并优化后的“特征掩码”作为输入，利用OpenCV的ECC（增强相关系数）算法，该算法对亮度线性变化不敏感，非常适合本场景。</li>\n<li>我系统性地测试了<strong>平移、欧几里得（包含了平移、旋转和等比缩放）、仿射、透视</strong>四种变换模型，并最终根据<strong>相关系数（CC）</strong>指标，选取了最优的变换模型。</li>\n</ul>\n<p><img src=\"/blog/cancerAI-2-1.png\" alt=\"alt text\"></p>\n<ul>\n<li><strong>第一行：特征提取</strong><ul>\n<li><strong>左侧两张 (H&amp;E)</strong>: 显示了从原始H&amp;E图中提取出的白色胆管区域（掩码）。</li>\n<li><strong>右侧两张 (荧光)</strong>: 显示了从原始荧光图中提取出的黑色胆管区域（掩码）。</li>\n</ul>\n</li>\n<li><strong>第二行：特征增强与叠加</strong><ul>\n<li><strong>左二 (增强特征)</strong>: 展示了经过距离变换和边缘增强后的胆管特征图。这些图像的灰度变化更丰富，纹理更清晰，非常适合ECC算法进行配准。</li>\n<li><strong>右二 (特征叠加)</strong>: 将提取的胆管掩码（红色&#x2F;绿色）叠加在原始图像上，直观地展示了程序识别的“锚点”位置是否准确。</li>\n</ul>\n</li>\n<li><strong>第三行：配准结果</strong><ul>\n<li><strong>配准后H&amp;E胆管特征</strong>: 这是将H&amp;E的特征图根据计算出的矩阵进行变换后的样子。</li>\n<li><strong>胆管特征差异图</strong>: 将配准后的H&amp;E特征图与荧光特征图相减得到的差异。图像越黑，说明差异越小，对齐效果越好。</li>\n<li><strong>胆管特征棋盘格对比</strong>: 将两张特征图拼接成棋盘格。如果对齐得好，您应该能看到胆管的结构在方格之间是连续的，没有明显的错位。</li>\n<li><strong>胆管特征叠加效果</strong>: 将两张特征图半透明地叠加在一起。如果对齐完美，它们的轮廓会高度重合，形成一个清晰的融合图像。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"核心成果与对后续工作的启发\"><a href=\"#核心成果与对后续工作的启发\" class=\"headerlink\" title=\"核心成果与对后续工作的启发\"></a>核心成果与对后续工作的启发</h4><p><strong>核心成果：</strong></p>\n<p>我成功实现了局部图像的<strong>全自动、高精度配准</strong>。最终在<code>HOMOGRAPHY</code>（透视）模型下，获得了高达<strong>0.9669</strong>的相关系数（CC），质量评估为“优秀”。我得到了一份精确的<strong>3x3变换矩阵</strong>，它以数学形式描述了将H&amp;E图像精准对齐到荧光图像上所需的全部几何变换（旋转、平移、缩放、透视）。</p>\n<p><img src=\"/blog/cancerAI-2-2.png\" alt=\"alt text\"></p>\n<ul>\n<li><code>HOMOGRAPHY</code>是本次测试中<strong>最复杂、最强大</strong>的2D变换模型。它不仅包含平移、旋转、缩放、剪切（这些<code>AFFINE</code>模型也能做到），还能够模拟<strong>透视畸变</strong>——就像我们从一个倾斜的角度看一个矩形，它会变成梯形一样。</li>\n<li><strong>为什么是它？</strong> 在所有四个模型中，<code>HOMOGRAPHY</code>取得了最高的<strong>相关系数（0.966946）</strong>，尽管只比次优的<code>AFFINE</code>模型（0.964276）高出一点点。这说明，在图像中可能存在极其微小的、非线性的形变（例如组织在切片或放置时产生的轻微褶皱或拉伸），而<code>HOMOGRAPHY</code>模型凭借其更高的自由度，捕捉到了这种细微的畸变，从而获得了最佳的匹配分数。</li>\n</ul>\n<hr>\n<p><strong>实现方式二：基于互信息的图像配准方案</strong><br>我们不直接比较两张图的“颜色”（像素值），因为它们本来就不同。而是采用一种更聪明的策略——**互信息 (Mutual Information)**。<br>它巧妙地绕开了不同模态图像像素值无法直接比较的难题，转而从统计学的角度寻找最佳对齐，使得该方法具有广泛的适用性和鲁棒性。</p>\n<h4 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h4><ol>\n<li><strong>选择工具:</strong> 使用强大的医学图像处理库 <code>SimpleITK</code> 来执行这个任务。</li>\n<li><strong>配置配准参数:</strong> 详细设置配准过程中的每一个环节，包括：</li>\n</ol>\n<ul>\n<li><p>用什么标准衡量对齐的好坏？**(Metric - 度量标准)**</p>\n</li>\n<li><p>如何“猜测”移动过程中非整数像素点的值？**(Interpolator - 插值器)**</p>\n</li>\n<li><p>用什么方法去寻找最佳的对齐位置？**(Optimizer - 优化器)**</p>\n</li>\n<li><p>允许对图像进行哪些类型的变换（移动、旋转、缩放）？**(Transform - 变换类型)**</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>执行与应用:</strong> 启动配准过程，找到最佳变换参数，并将这个变换应用到需要对齐的图像上，生成最终对齐好的图像。</li>\n</ol>\n<h4 id=\"工具库介绍\"><a href=\"#工具库介绍\" class=\"headerlink\" title=\"工具库介绍\"></a>工具库介绍</h4><ol>\n<li><code>SimpleITK</code></li>\n</ol>\n<ul>\n<li><p>作用: 这是实现图像配准的核心工具。它是一个专门为处理和分析多维生物医学图像（2D, 3D, 4D）而设计的开源库。</p>\n</li>\n<li><p><code>SimpleITK</code> 就像一个装备齐全的<strong>“专业地图对齐工作室”</strong>。它里面不仅有尺子、量角器（用于<strong>测量和变换</strong>），还有一套完整的工作流程和自动化设备（<strong>配准框架</strong>），可以高效、精确地完成地图对齐任务。代码中的 <code>ImageRegistrationMethod</code> 就是这个工作室里的核心<strong>自动化设备</strong>。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><code>scikit-image</code></li>\n</ol>\n<ul>\n<li><p>作用: 一个通用的图像处理库。在配准前后，你可能需要用它进行一些<strong>预处理或后处理</strong>，比如图像裁剪、降噪、格式转换等。</p>\n</li>\n<li><p>如果 SimpleITK 是专业工作室，那 scikit-image 就是一个非常方便的<strong>“多功能工具箱”</strong>。在把地图送进工作室之前，你可能需要用这个工具箱里的剪刀（裁剪）、清洁布（降噪）来整理一下地图。</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><code>napari</code></li>\n</ol>\n<ul>\n<li><p>作用: 一个为科学家设计的、交互式的多维数据可视化工具。在配准任务中，它的作用至关重要：可以非常直观地检查配准前和配准后的效果。你可以将配准前的两张图以不同颜色叠加显示，看到它们是错位的；配准后，再将固定图像和变形后的移动图像叠加显示，检查对齐的精度。</p>\n</li>\n<li><p><code>napari</code> 就像一个高精度的“数字灯箱”。你可以把两张地图（图像）作为不同的图层放上去，调节每个图层的透明度，放大缩小，来仔细比对河流和城市峡谷是否真的对齐了。没有它，你只能通过数字来判断效果，非常不直观。</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li><code>CycleGAN</code></li>\n</ol>\n<ul>\n<li>作用: 这是一种深度学习模型，属于生成对抗网络（GAN）的一种。它可以学习将一种风格的图像转换成另一种风格，例如，将H&amp;E染色的图像“翻译”成看起来像是DAPI染色的图像。</li>\n</ul>\n<blockquote>\n<p>如果H&amp;E和DAPI图像的差异巨大，以至于互信息这种统计方法也难以奏效时，可以先用CycleGAN将H&amp;E图像伪染成“伪DAPI”图像。这样，配准任务就从“多模态”（H&amp;E vs DAPI）变成了“单模态”（伪DAPI vs DAPI），难度会大大降低。</p>\n<p>假设你的“地形图”是黑白素描风格，而“水文图”是彩色油画风格，差异太大导致对齐困难。CycleGAN 就像一位“艺术风格模仿大师”，可以学习素描和油画的风格，然后帮你把黑白的“地形图”重新绘制成一张彩色油画风格的“地形图”。这样你手里就有了两张风格相似的油画，对齐起来就容易多了。</p>\n</blockquote>\n<h4 id=\"互信息\"><a href=\"#互信息\" class=\"headerlink\" title=\"互信息\"></a>互信息</h4><p>它不关心像素值的绝对大小，而是关心像素值分布的统计依赖性。</p>\n<blockquote>\n<p>想象一下，一个只会说中文的人（代表H&amp;E图像）和一个只会说英语的人（代表DAPI图像）被关在一个房间里。他们无法直接沟通（像素值无法直接比较）。<br>但是，如果每次房间里出现“苹果”（H&amp;E图像中出现某个特定范围的像素值）时，那个说英语的人总会说出”Apple”（DAPI图像中对应位置也出现某个特定范围的像素值）。即使你听不懂”Apple”是什么意思，但你观察久了就会发现，“苹果”这个词的出现，可以很好地预测对方会说”Apple”这个词。</p>\n</blockquote>\n<p>互信息就衡量的是这种“预测能力”有多强。如果一个信号（H&amp;E的像素值）的出现，能极大地减少另一个信号（DAPI的像素值）的不确定性，那么它们之间的互信息就很高。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> SimpleITK <span class=\"keyword\">as</span> sitk</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 导入图像文件：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># fixed_image: H&amp;E苏木精通道 (作为参考)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># moving_image: DAPI通道 (需要被移动对齐的图像)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1. 实例化配准方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">registration_method = sitk.ImageRegistrationMethod()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 设置度量标准 (Metric) - Mattes Mutual Information</span></span><br><span class=\"line\"></span><br><span class=\"line\">registration_method.SetMetricAsMattesMutualInformation(numberOfHistogramBins=<span class=\"number\">50</span>)//将图像的连续像素值<span class=\"number\">0</span>~<span class=\"number\">255</span>分成<span class=\"number\">50</span>个桶。通过统计两个图像中来自不同的“桶”的像素对出现的频率来计算互信息。</span><br><span class=\"line\"></span><br><span class=\"line\">registration_method.SetMetricSamplingStrategy(registration_method.RANDOM)//随机采样部分像素来计算，可节省计算资源</span><br><span class=\"line\"></span><br><span class=\"line\">registration_method.SetMetricSamplingPercentage(<span class=\"number\">0.01</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 设置插值器 (Interpolator)</span></span><br><span class=\"line\"></span><br><span class=\"line\">registration_method.SetInterpolator(sitk.sitkLinear)</span><br><span class=\"line\">//当我们对图像进行旋转缩放时，它的原始像素点的位置会发生变化。通过线性插值可以合理地猜测出这个新的位置应该时什么像素值。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 设置优化器 (Optimizer)</span></span><br><span class=\"line\"></span><br><span class=\"line\">registration_methodSetOptimizerAsRegularStepGradientDescent(learningRate=<span class=\"number\">1.0</span>, minStep=<span class=\"number\">0.001</span>, numberOfIterations=<span class=\"number\">200</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 设置变换类型 (Transform) - 从简单的刚性或仿射变换开始</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># initial_transform = sitk.CenteredTransformInitializer(fixed_image, </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#                                                       moving_image, </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#                                                       sitk.Euler2DTransform(), </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#                                                       sitk.CenteredTransformInitializerFilter.GEOMETRY)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># registration_method.SetInitialTransform(initial_transform)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">final_transform = sitk.Similarity2DTransform() <span class=\"comment\"># 仿射变换的一种</span></span><br><span class=\"line\"></span><br><span class=\"line\">registration_method.SetInitialTransform(final_transform)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 6. 执行配准</span></span><br><span class=\"line\"></span><br><span class=\"line\">final_transform = registration_method.Execute(fixed_image, moving_image)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Final Transform: <span class=\"subst\">&#123;final_transform&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Optimizer stop condition: <span class=\"subst\">&#123;registration_method.GetOptimizerStopConditionDescription()&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 7. 应用变换</span></span><br><span class=\"line\"></span><br><span class=\"line\">resampler = sitk.ResampleImageFilter()</span><br><span class=\"line\"></span><br><span class=\"line\">resampler.SetReferenceImage(fixed_image)</span><br><span class=\"line\"></span><br><span class=\"line\">resampler.SetInterpolator(sitk.sitkLinear)</span><br><span class=\"line\"></span><br><span class=\"line\">resampler.SetTransform(final_transform)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">warped_moving_image = resampler.Execute(moving_image)</span><br></pre></td></tr></table></figure>"},{"layout":"posts","title":"day2-react-learning","date":"2025-07-09T02:04:27.000Z","_content":"用模拟数据写了一个作业管理的详情页，react可以用mock拦截前端发出去的请求，所以可以在这里放置模拟数据。\n给了一个类似这样的界面：\n![alt text](day2-react-learning-1.png)\n### **一、 页面结构设计**\n首先确定了把整个页面拆分成三个组件（上basicinfocard下documenttablecard），还有一个根组件jobdetail来负责获取jobid，管理整体的加载状态并组织子组件的渲染。\n-   `BasicInfoCard`：用于展示顶部的基础信息。\n-   `DocumentTableCard`：用于展示下方的文档列表。\n-   `JobDetail`：作为根组件，负责从 URL 获取 `jobId`，管理整体的加载状态，并组织上述子组件的渲染。\n### **二、 数据交互与状态管理**\n接着是和后端的交互：\n#### **1. 异步获取数据**\n在 `JobDetail` 组件中，使用了 `useEffect` Hook。当组件首次加载或 `jobId` 变化时，它会自动调用 `service/job.ts` 中定义的接口函数 `getJobDocuments`，从后端异步获取文档列表数据。\n#### **2. 存储和处理数据**\n- 使用useState创建dataSource状态，用于存储从后端获取的完整文档列表。获取到数据之后，对每条记录增加一个唯一的key属性来满足protable的要求。\n*protable功能确实挺丰富，部署起来也挺快捷的。这里先把它稍微进行了一下更改再拿来用，学习文档：https://procomponents.ant.design/components/table*\n### **三、 ProTable 核心功能实现**\n#### **1. 行选择与批量下载**\n    1. 创建了一个selectedRowKeys状态数组用来存放所有被勾选的行的key。\n    2. 该列用render的方法返回一个<Checkbox>，其勾选状态与selectedRowKeys双向绑定。\n    3. 该列的 title 属性也返回一个 <Checkbox>，作为“全选/取消全选”的控制器。其 checked 和 indeterminate (半选) 状态根据 selectedRowKeys 和 dataSource 的长度动态计算，实现了精确的全选逻辑。\n#### **2. 点击查看日志**\n在名称列，将其渲染为一个`<Button type=\"link\">`，使其外观像一个可点击的链接。点击后，通过更新 `logModalVisible` 状态来控制 `<Modal>` 弹窗的显示与隐藏，从而展示日志内容。\n#### **3. 自定义搜索**\n由于 ProTable 自带搜索的自定义空间有限，我选择实现一个自定义的搜索功能：\n1.  在表格外部放置一个 `<Input.Search>` 组件。\n2.  监听其 `onSearch` 事件，并将输入值更新到 `searchText` 状态。\n3.  创建一个派生状态 `filteredDataSource`。它通过对原始 `dataSource` 数组使用 `.filter()` 方法，根据 `searchText` 的值进行客户端实时过滤。\n4.  将 `ProTable` 的 `dataSource` 属性直接指向这个过滤后的 `filteredDataSource`，从而实现了自定义搜索。\n\n### **四、 React Hooks 学习总结**\n#### **1. `useState`：组件的记忆**\n- 相当于内部记忆（可修改的便签纸），用于为函数组件添加状态。\n- 比如const [logModalVisible（便签纸）, setLogModalVisible（专用于修改便签纸的笔）] = useState(false)，其中logModalVisible的状态就是false。我们可以并只能通过调用setLogModalVisible(true)来更新便签纸的状态。\n    -   **示例**：\n    ````javascript\n    function Counter() {\n      // 声明一个名为 \"count\" 的 state 变量，初始化为 0\n      const [count, setCount] = useState(0);\n\n      return (\n        <div>\n          <p>You clicked {count} times</p>\n          {/* 调用 setCount 来更新 state */}\n          <button onClick={() => setCount(count + 1)}>\n            Click me\n          </button>\n        </div>\n      );\n    }\n    ````\n> **与 `useParams` 的区别**：相当于外部指令（门牌号），来自于网页的url地址，而不是内部的组件。它只能读取而无法控制。比如说const { jobId } = useParams();就相当于看了一眼网页地址的门牌号，但是无法修改门牌。\n#### **2. `useEffect`：处理副作用**\n-   **作用**：让函数组件能够在特定时机（如渲染后、依赖变化后）执行一些份外的事情（比如去服务器拿东西），例如数据获取、DOM 操作、设置订阅等。\n-   **类比**：它是一条“如果...就...”的指令。`useEffect(() => { fetchData(); }, [jobId]);` 意味着：“如果 `jobId` 变了，就去服务器获取一次新数据”。\n-   **依赖数组说明**：\n    -   `[dep1, dep2]`: 依赖项 `dep1` 或 `dep2` 发生变化时执行。\n    -   `[]` (空数组): 只在组件**首次挂载**后执行一次。\n    -   **不提供**依赖数组: **每次组件渲染后**都会执行。\n比如useEffect(() => { fetchData(); }, [jobId]);\n其中fetchData()意思是去服务器中拿回文件列表，jobid就是触发的ID（如果这个id发生了改变就去服务器拿回文件列表，但是如果还是同一个id的话就不需要跑一趟，用现有的就行。）\n注意：①如果指令的触发条件是[]，意思即使开机后只执行一次以后都不管了；②如果没有触发条件，意思是任何一点风吹草动都要去执行这个指令。\n-   **示例**：\n    ````javascript\n    function UserInfo({ userId }) {\n      const [user, setUser] = useState(null);\n\n      useEffect(() => {\n        // 当 userId 变化时，执行这个副作用\n        fetch(`/api/users/${userId}`)\n          .then(res => res.json())\n          .then(data => setUser(data));\n      }, [userId]); // 依赖项是 userId\n\n      if (!user) return 'Loading...';\n      return <div>{user.name}</div>;\n    }\n    ````\n#### **3. `useContext`：全局广播**\n- 相当于公共广播系统。顶层组件可以通过广播发布信息，比如广播“当前主题：夜间模式”，那么所有组件（深层的也可以）只要打开收音机都会听到这个信息。\n-   **示例**：\n    ````javascript\n    // 1. 创建 Context\n    const ThemeContext = React.createContext('light');\n\n    // 2. 在顶层组件使用 Provider 提供 value\n    function App() {\n      return (\n        <ThemeContext.Provider value=\"dark\">\n          <Toolbar />\n        </ThemeContext.Provider>\n      );\n    }\n\n    // 3. 在子组件中使用 useContext 消费 value\n    function ThemedButton() {\n      const theme = useContext(ThemeContext); // theme 的值会是 \"dark\"\n      return <button className={theme}>I am a {theme} button</button>;\n    }\n    ````\n\n#### **4. `useMemo`：记住计算结果**\n- 用于记住一个复杂的计算结果（重在**结果**），避免重复计算。\n-   **示例**：\n    ````javascript\n    function ExpensiveComponent({ list, filter }) {\n      // 只有当 list 或 filter 变化时，才会重新执行 filter 操作\n      const visibleList = useMemo(() => {\n        console.log('Filtering list...'); // 这个 log 不会频繁触发\n        return list.filter(item => item.includes(filter));\n      }, [list, filter]);\n\n      return <div>{/* ... render visibleList ... */}</div>;\n    }\n    ````\n#### **5. `useCallback`：记住函数本身**\n用于记住一个计算公式（重在**函数实例**）。这在传递给子组件时非常有用。\n-   **示例**：\n    ````javascript\n    function Parent() {\n      const [count, setCount] = useState(0);\n      \n      // 使用 useCallback，这个 handleClick 函数实例在重渲染时保持不变\n      const handleClick = useCallback(() => {\n        console.log('Button clicked!');\n      }, []); // 空依赖数组意味着函数永不改变\n\n      return <Child onClick={handleClick} />;\n    }\n    // React.memo 可以防止在 props 不变时重渲染子组件\n    const Child = React.memo(({ onClick }) => {\n      console.log('Child rendered');\n      return <button onClick={onClick}>Click me</button>;\n    });\n    ````\n#### **6. `useRef`：多功能工具箱**\n- 相当于多功能工具箱，无论怎么刷新箱子里的东西都是同一个不会丢失。修改箱子里的东西也不会触发重新渲染。\n-   **作用**：返回一个可变的 ref 对象，其 `.current` 属性被初始化为传入的参数。它可以在多次渲染之间保持不变。\n-   **特点**：修改 `ref.current` **不会**触发组件的重新渲染。\n-   **常见用途**：\n    1.  **访问 DOM 元素**：直接操作 DOM，如聚焦输入框。\n    2.  **存储可变值**：存储一个与渲染无关的值，类似于实例变量。\n-   **示例**：\n    ````javascript\n    function TextInputWithFocusButton() {\n      const inputEl = useRef(null);\n      \n      const onButtonClick = () => {\n        // `current` 指向已挂载到 DOM 上的 text input 元素\n        inputEl.current.focus();\n      };\n\n      return (\n        <>\n          <input ref={inputEl} type=\"text\" />\n          <button onClick={onButtonClick}>Focus the input</button>\n        </>\n      );\n    }\n    ````","source":"_posts/day2-react-learning.md","raw":"---\nlayout: posts\ntitle: day2-react-learning\ndate: 2025-07-09 10:04:27\ntags: [react, web前端, 实习日记]\n---\n用模拟数据写了一个作业管理的详情页，react可以用mock拦截前端发出去的请求，所以可以在这里放置模拟数据。\n给了一个类似这样的界面：\n![alt text](day2-react-learning-1.png)\n### **一、 页面结构设计**\n首先确定了把整个页面拆分成三个组件（上basicinfocard下documenttablecard），还有一个根组件jobdetail来负责获取jobid，管理整体的加载状态并组织子组件的渲染。\n-   `BasicInfoCard`：用于展示顶部的基础信息。\n-   `DocumentTableCard`：用于展示下方的文档列表。\n-   `JobDetail`：作为根组件，负责从 URL 获取 `jobId`，管理整体的加载状态，并组织上述子组件的渲染。\n### **二、 数据交互与状态管理**\n接着是和后端的交互：\n#### **1. 异步获取数据**\n在 `JobDetail` 组件中，使用了 `useEffect` Hook。当组件首次加载或 `jobId` 变化时，它会自动调用 `service/job.ts` 中定义的接口函数 `getJobDocuments`，从后端异步获取文档列表数据。\n#### **2. 存储和处理数据**\n- 使用useState创建dataSource状态，用于存储从后端获取的完整文档列表。获取到数据之后，对每条记录增加一个唯一的key属性来满足protable的要求。\n*protable功能确实挺丰富，部署起来也挺快捷的。这里先把它稍微进行了一下更改再拿来用，学习文档：https://procomponents.ant.design/components/table*\n### **三、 ProTable 核心功能实现**\n#### **1. 行选择与批量下载**\n    1. 创建了一个selectedRowKeys状态数组用来存放所有被勾选的行的key。\n    2. 该列用render的方法返回一个<Checkbox>，其勾选状态与selectedRowKeys双向绑定。\n    3. 该列的 title 属性也返回一个 <Checkbox>，作为“全选/取消全选”的控制器。其 checked 和 indeterminate (半选) 状态根据 selectedRowKeys 和 dataSource 的长度动态计算，实现了精确的全选逻辑。\n#### **2. 点击查看日志**\n在名称列，将其渲染为一个`<Button type=\"link\">`，使其外观像一个可点击的链接。点击后，通过更新 `logModalVisible` 状态来控制 `<Modal>` 弹窗的显示与隐藏，从而展示日志内容。\n#### **3. 自定义搜索**\n由于 ProTable 自带搜索的自定义空间有限，我选择实现一个自定义的搜索功能：\n1.  在表格外部放置一个 `<Input.Search>` 组件。\n2.  监听其 `onSearch` 事件，并将输入值更新到 `searchText` 状态。\n3.  创建一个派生状态 `filteredDataSource`。它通过对原始 `dataSource` 数组使用 `.filter()` 方法，根据 `searchText` 的值进行客户端实时过滤。\n4.  将 `ProTable` 的 `dataSource` 属性直接指向这个过滤后的 `filteredDataSource`，从而实现了自定义搜索。\n\n### **四、 React Hooks 学习总结**\n#### **1. `useState`：组件的记忆**\n- 相当于内部记忆（可修改的便签纸），用于为函数组件添加状态。\n- 比如const [logModalVisible（便签纸）, setLogModalVisible（专用于修改便签纸的笔）] = useState(false)，其中logModalVisible的状态就是false。我们可以并只能通过调用setLogModalVisible(true)来更新便签纸的状态。\n    -   **示例**：\n    ````javascript\n    function Counter() {\n      // 声明一个名为 \"count\" 的 state 变量，初始化为 0\n      const [count, setCount] = useState(0);\n\n      return (\n        <div>\n          <p>You clicked {count} times</p>\n          {/* 调用 setCount 来更新 state */}\n          <button onClick={() => setCount(count + 1)}>\n            Click me\n          </button>\n        </div>\n      );\n    }\n    ````\n> **与 `useParams` 的区别**：相当于外部指令（门牌号），来自于网页的url地址，而不是内部的组件。它只能读取而无法控制。比如说const { jobId } = useParams();就相当于看了一眼网页地址的门牌号，但是无法修改门牌。\n#### **2. `useEffect`：处理副作用**\n-   **作用**：让函数组件能够在特定时机（如渲染后、依赖变化后）执行一些份外的事情（比如去服务器拿东西），例如数据获取、DOM 操作、设置订阅等。\n-   **类比**：它是一条“如果...就...”的指令。`useEffect(() => { fetchData(); }, [jobId]);` 意味着：“如果 `jobId` 变了，就去服务器获取一次新数据”。\n-   **依赖数组说明**：\n    -   `[dep1, dep2]`: 依赖项 `dep1` 或 `dep2` 发生变化时执行。\n    -   `[]` (空数组): 只在组件**首次挂载**后执行一次。\n    -   **不提供**依赖数组: **每次组件渲染后**都会执行。\n比如useEffect(() => { fetchData(); }, [jobId]);\n其中fetchData()意思是去服务器中拿回文件列表，jobid就是触发的ID（如果这个id发生了改变就去服务器拿回文件列表，但是如果还是同一个id的话就不需要跑一趟，用现有的就行。）\n注意：①如果指令的触发条件是[]，意思即使开机后只执行一次以后都不管了；②如果没有触发条件，意思是任何一点风吹草动都要去执行这个指令。\n-   **示例**：\n    ````javascript\n    function UserInfo({ userId }) {\n      const [user, setUser] = useState(null);\n\n      useEffect(() => {\n        // 当 userId 变化时，执行这个副作用\n        fetch(`/api/users/${userId}`)\n          .then(res => res.json())\n          .then(data => setUser(data));\n      }, [userId]); // 依赖项是 userId\n\n      if (!user) return 'Loading...';\n      return <div>{user.name}</div>;\n    }\n    ````\n#### **3. `useContext`：全局广播**\n- 相当于公共广播系统。顶层组件可以通过广播发布信息，比如广播“当前主题：夜间模式”，那么所有组件（深层的也可以）只要打开收音机都会听到这个信息。\n-   **示例**：\n    ````javascript\n    // 1. 创建 Context\n    const ThemeContext = React.createContext('light');\n\n    // 2. 在顶层组件使用 Provider 提供 value\n    function App() {\n      return (\n        <ThemeContext.Provider value=\"dark\">\n          <Toolbar />\n        </ThemeContext.Provider>\n      );\n    }\n\n    // 3. 在子组件中使用 useContext 消费 value\n    function ThemedButton() {\n      const theme = useContext(ThemeContext); // theme 的值会是 \"dark\"\n      return <button className={theme}>I am a {theme} button</button>;\n    }\n    ````\n\n#### **4. `useMemo`：记住计算结果**\n- 用于记住一个复杂的计算结果（重在**结果**），避免重复计算。\n-   **示例**：\n    ````javascript\n    function ExpensiveComponent({ list, filter }) {\n      // 只有当 list 或 filter 变化时，才会重新执行 filter 操作\n      const visibleList = useMemo(() => {\n        console.log('Filtering list...'); // 这个 log 不会频繁触发\n        return list.filter(item => item.includes(filter));\n      }, [list, filter]);\n\n      return <div>{/* ... render visibleList ... */}</div>;\n    }\n    ````\n#### **5. `useCallback`：记住函数本身**\n用于记住一个计算公式（重在**函数实例**）。这在传递给子组件时非常有用。\n-   **示例**：\n    ````javascript\n    function Parent() {\n      const [count, setCount] = useState(0);\n      \n      // 使用 useCallback，这个 handleClick 函数实例在重渲染时保持不变\n      const handleClick = useCallback(() => {\n        console.log('Button clicked!');\n      }, []); // 空依赖数组意味着函数永不改变\n\n      return <Child onClick={handleClick} />;\n    }\n    // React.memo 可以防止在 props 不变时重渲染子组件\n    const Child = React.memo(({ onClick }) => {\n      console.log('Child rendered');\n      return <button onClick={onClick}>Click me</button>;\n    });\n    ````\n#### **6. `useRef`：多功能工具箱**\n- 相当于多功能工具箱，无论怎么刷新箱子里的东西都是同一个不会丢失。修改箱子里的东西也不会触发重新渲染。\n-   **作用**：返回一个可变的 ref 对象，其 `.current` 属性被初始化为传入的参数。它可以在多次渲染之间保持不变。\n-   **特点**：修改 `ref.current` **不会**触发组件的重新渲染。\n-   **常见用途**：\n    1.  **访问 DOM 元素**：直接操作 DOM，如聚焦输入框。\n    2.  **存储可变值**：存储一个与渲染无关的值，类似于实例变量。\n-   **示例**：\n    ````javascript\n    function TextInputWithFocusButton() {\n      const inputEl = useRef(null);\n      \n      const onButtonClick = () => {\n        // `current` 指向已挂载到 DOM 上的 text input 元素\n        inputEl.current.focus();\n      };\n\n      return (\n        <>\n          <input ref={inputEl} type=\"text\" />\n          <button onClick={onButtonClick}>Focus the input</button>\n        </>\n      );\n    }\n    ````","slug":"day2-react-learning","published":1,"updated":"2025-07-12T12:06:57.636Z","comments":1,"photos":[],"_id":"cmd15y0wb0005lstvfnn46jmb","content":"<p>用模拟数据写了一个作业管理的详情页，react可以用mock拦截前端发出去的请求，所以可以在这里放置模拟数据。<br>给了一个类似这样的界面：<br><img src=\"/blog/day2-react-learning-1.png\" alt=\"alt text\"></p>\n<h3 id=\"一、-页面结构设计\"><a href=\"#一、-页面结构设计\" class=\"headerlink\" title=\"一、 页面结构设计\"></a><strong>一、 页面结构设计</strong></h3><p>首先确定了把整个页面拆分成三个组件（上basicinfocard下documenttablecard），还有一个根组件jobdetail来负责获取jobid，管理整体的加载状态并组织子组件的渲染。</p>\n<ul>\n<li><code>BasicInfoCard</code>：用于展示顶部的基础信息。</li>\n<li><code>DocumentTableCard</code>：用于展示下方的文档列表。</li>\n<li><code>JobDetail</code>：作为根组件，负责从 URL 获取 <code>jobId</code>，管理整体的加载状态，并组织上述子组件的渲染。</li>\n</ul>\n<h3 id=\"二、-数据交互与状态管理\"><a href=\"#二、-数据交互与状态管理\" class=\"headerlink\" title=\"二、 数据交互与状态管理\"></a><strong>二、 数据交互与状态管理</strong></h3><p>接着是和后端的交互：</p>\n<h4 id=\"1-异步获取数据\"><a href=\"#1-异步获取数据\" class=\"headerlink\" title=\"1. 异步获取数据\"></a><strong>1. 异步获取数据</strong></h4><p>在 <code>JobDetail</code> 组件中，使用了 <code>useEffect</code> Hook。当组件首次加载或 <code>jobId</code> 变化时，它会自动调用 <code>service/job.ts</code> 中定义的接口函数 <code>getJobDocuments</code>，从后端异步获取文档列表数据。</p>\n<h4 id=\"2-存储和处理数据\"><a href=\"#2-存储和处理数据\" class=\"headerlink\" title=\"2. 存储和处理数据\"></a><strong>2. 存储和处理数据</strong></h4><ul>\n<li>使用useState创建dataSource状态，用于存储从后端获取的完整文档列表。获取到数据之后，对每条记录增加一个唯一的key属性来满足protable的要求。<br><em>protable功能确实挺丰富，部署起来也挺快捷的。这里先把它稍微进行了一下更改再拿来用，学习文档：<a href=\"https://procomponents.ant.design/components/table\">https://procomponents.ant.design/components/table</a></em></li>\n</ul>\n<h3 id=\"三、-ProTable-核心功能实现\"><a href=\"#三、-ProTable-核心功能实现\" class=\"headerlink\" title=\"三、 ProTable 核心功能实现\"></a><strong>三、 ProTable 核心功能实现</strong></h3><h4 id=\"1-行选择与批量下载\"><a href=\"#1-行选择与批量下载\" class=\"headerlink\" title=\"1. 行选择与批量下载\"></a><strong>1. 行选择与批量下载</strong></h4><pre><code>1. 创建了一个selectedRowKeys状态数组用来存放所有被勾选的行的key。\n2. 该列用render的方法返回一个&lt;Checkbox&gt;，其勾选状态与selectedRowKeys双向绑定。\n3. 该列的 title 属性也返回一个 &lt;Checkbox&gt;，作为“全选/取消全选”的控制器。其 checked 和 indeterminate (半选) 状态根据 selectedRowKeys 和 dataSource 的长度动态计算，实现了精确的全选逻辑。\n</code></pre>\n<h4 id=\"2-点击查看日志\"><a href=\"#2-点击查看日志\" class=\"headerlink\" title=\"2. 点击查看日志\"></a><strong>2. 点击查看日志</strong></h4><p>在名称列，将其渲染为一个<code>&lt;Button type=&quot;link&quot;&gt;</code>，使其外观像一个可点击的链接。点击后，通过更新 <code>logModalVisible</code> 状态来控制 <code>&lt;Modal&gt;</code> 弹窗的显示与隐藏，从而展示日志内容。</p>\n<h4 id=\"3-自定义搜索\"><a href=\"#3-自定义搜索\" class=\"headerlink\" title=\"3. 自定义搜索\"></a><strong>3. 自定义搜索</strong></h4><p>由于 ProTable 自带搜索的自定义空间有限，我选择实现一个自定义的搜索功能：</p>\n<ol>\n<li>在表格外部放置一个 <code>&lt;Input.Search&gt;</code> 组件。</li>\n<li>监听其 <code>onSearch</code> 事件，并将输入值更新到 <code>searchText</code> 状态。</li>\n<li>创建一个派生状态 <code>filteredDataSource</code>。它通过对原始 <code>dataSource</code> 数组使用 <code>.filter()</code> 方法，根据 <code>searchText</code> 的值进行客户端实时过滤。</li>\n<li>将 <code>ProTable</code> 的 <code>dataSource</code> 属性直接指向这个过滤后的 <code>filteredDataSource</code>，从而实现了自定义搜索。</li>\n</ol>\n<h3 id=\"四、-React-Hooks-学习总结\"><a href=\"#四、-React-Hooks-学习总结\" class=\"headerlink\" title=\"四、 React Hooks 学习总结\"></a><strong>四、 React Hooks 学习总结</strong></h3><h4 id=\"1-useState：组件的记忆\"><a href=\"#1-useState：组件的记忆\" class=\"headerlink\" title=\"1. useState：组件的记忆\"></a><strong>1. <code>useState</code>：组件的记忆</strong></h4><ul>\n<li>相当于内部记忆（可修改的便签纸），用于为函数组件添加状态。</li>\n<li>比如const [logModalVisible（便签纸）, setLogModalVisible（专用于修改便签纸的笔）] &#x3D; useState(false)，其中logModalVisible的状态就是false。我们可以并只能通过调用setLogModalVisible(true)来更新便签纸的状态。<ul>\n<li><strong>示例</strong>：  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Counter</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 声明一个名为 &quot;count&quot; 的 state 变量，初始化为 0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      &#123;/* 调用 setCount 来更新 state */&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">        Click me</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>与 <code>useParams</code> 的区别</strong>：相当于外部指令（门牌号），来自于网页的url地址，而不是内部的组件。它只能读取而无法控制。比如说const { jobId } &#x3D; useParams();就相当于看了一眼网页地址的门牌号，但是无法修改门牌。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-useEffect：处理副作用\"><a href=\"#2-useEffect：处理副作用\" class=\"headerlink\" title=\"2. useEffect：处理副作用\"></a><strong>2. <code>useEffect</code>：处理副作用</strong></h4><ul>\n<li><strong>作用</strong>：让函数组件能够在特定时机（如渲染后、依赖变化后）执行一些份外的事情（比如去服务器拿东西），例如数据获取、DOM 操作、设置订阅等。</li>\n<li><strong>类比</strong>：它是一条“如果…就…”的指令。<code>useEffect(() =&gt; &#123; fetchData(); &#125;, [jobId]);</code> 意味着：“如果 <code>jobId</code> 变了，就去服务器获取一次新数据”。</li>\n<li><strong>依赖数组说明</strong>：<ul>\n<li><code>[dep1, dep2]</code>: 依赖项 <code>dep1</code> 或 <code>dep2</code> 发生变化时执行。</li>\n<li><code>[]</code> (空数组): 只在组件<strong>首次挂载</strong>后执行一次。</li>\n<li><strong>不提供</strong>依赖数组: <strong>每次组件渲染后</strong>都会执行。<br>比如useEffect(() &#x3D;&gt; { fetchData(); }, [jobId]);<br>其中fetchData()意思是去服务器中拿回文件列表，jobid就是触发的ID（如果这个id发生了改变就去服务器拿回文件列表，但是如果还是同一个id的话就不需要跑一趟，用现有的就行。）<br>注意：①如果指令的触发条件是[]，意思即使开机后只执行一次以后都不管了；②如果没有触发条件，意思是任何一点风吹草动都要去执行这个指令。</li>\n</ul>\n</li>\n<li><strong>示例</strong>：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">UserInfo</span>(<span class=\"params\">&#123; userId &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [user, setUser] = <span class=\"title function_\">useState</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当 userId 变化时，执行这个副作用</span></span><br><span class=\"line\">    <span class=\"title function_\">fetch</span>(<span class=\"string\">`/api/users/<span class=\"subst\">$&#123;userId&#125;</span>`</span>)</span><br><span class=\"line\">      .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.<span class=\"title function_\">json</span>())</span><br><span class=\"line\">      .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> <span class=\"title function_\">setUser</span>(data));</span><br><span class=\"line\">  &#125;, [userId]); <span class=\"comment\">// 依赖项是 userId</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!user) <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Loading...&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;user.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"3-useContext：全局广播\"><a href=\"#3-useContext：全局广播\" class=\"headerlink\" title=\"3. useContext：全局广播\"></a><strong>3. <code>useContext</code>：全局广播</strong></h4><ul>\n<li>相当于公共广播系统。顶层组件可以通过广播发布信息，比如广播“当前主题：夜间模式”，那么所有组件（深层的也可以）只要打开收音机都会听到这个信息。</li>\n<li><strong>示例</strong>：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 创建 Context</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ThemeContext</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">createContext</span>(<span class=\"string\">&#x27;light&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在顶层组件使用 Provider 提供 value</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">ThemeContext.Provider</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;dark&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Toolbar</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">ThemeContext.Provider</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 在子组件中使用 useContext 消费 value</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ThemedButton</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> theme = <span class=\"title function_\">useContext</span>(<span class=\"title class_\">ThemeContext</span>); <span class=\"comment\">// theme 的值会是 &quot;dark&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;theme&#125;</span>&gt;</span>I am a &#123;theme&#125; button<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"4-useMemo：记住计算结果\"><a href=\"#4-useMemo：记住计算结果\" class=\"headerlink\" title=\"4. useMemo：记住计算结果\"></a><strong>4. <code>useMemo</code>：记住计算结果</strong></h4><ul>\n<li>用于记住一个复杂的计算结果（重在<strong>结果</strong>），避免重复计算。</li>\n<li><strong>示例</strong>：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ExpensiveComponent</span>(<span class=\"params\">&#123; list, filter &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 只有当 list 或 filter 变化时，才会重新执行 filter 操作</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> visibleList = <span class=\"title function_\">useMemo</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Filtering list...&#x27;</span>); <span class=\"comment\">// 这个 log 不会频繁触发</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> list.<span class=\"title function_\">filter</span>(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.<span class=\"title function_\">includes</span>(filter));</span><br><span class=\"line\">  &#125;, [list, filter]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;/* ... render visibleList ... */&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"5-useCallback：记住函数本身\"><a href=\"#5-useCallback：记住函数本身\" class=\"headerlink\" title=\"5. useCallback：记住函数本身\"></a><strong>5. <code>useCallback</code>：记住函数本身</strong></h4><p>用于记住一个计算公式（重在<strong>函数实例</strong>）。这在传递给子组件时非常有用。</p>\n<ul>\n<li><strong>示例</strong>：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Parent</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 使用 useCallback，这个 handleClick 函数实例在重渲染时保持不变</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> handleClick = <span class=\"title function_\">useCallback</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Button clicked!&#x27;</span>);</span><br><span class=\"line\">  &#125;, []); <span class=\"comment\">// 空依赖数组意味着函数永不改变</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Child</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;handleClick&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// React.memo 可以防止在 props 不变时重渲染子组件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Child</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">memo</span>(<span class=\"function\">(<span class=\"params\">&#123; onClick &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Child rendered&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;onClick&#125;</span>&gt;</span>Click me<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"6-useRef：多功能工具箱\"><a href=\"#6-useRef：多功能工具箱\" class=\"headerlink\" title=\"6. useRef：多功能工具箱\"></a><strong>6. <code>useRef</code>：多功能工具箱</strong></h4><ul>\n<li>相当于多功能工具箱，无论怎么刷新箱子里的东西都是同一个不会丢失。修改箱子里的东西也不会触发重新渲染。</li>\n<li><strong>作用</strong>：返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数。它可以在多次渲染之间保持不变。</li>\n<li><strong>特点</strong>：修改 <code>ref.current</code> <strong>不会</strong>触发组件的重新渲染。</li>\n<li><strong>常见用途</strong>：<ol>\n<li><strong>访问 DOM 元素</strong>：直接操作 DOM，如聚焦输入框。</li>\n<li><strong>存储可变值</strong>：存储一个与渲染无关的值，类似于实例变量。</li>\n</ol>\n</li>\n<li><strong>示例</strong>：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">TextInputWithFocusButton</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> inputEl = <span class=\"title function_\">useRef</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">onButtonClick</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// `current` 指向已挂载到 DOM 上的 text input 元素</span></span><br><span class=\"line\">    inputEl.<span class=\"property\">current</span>.<span class=\"title function_\">focus</span>();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">ref</span>=<span class=\"string\">&#123;inputEl&#125;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;onButtonClick&#125;</span>&gt;</span>Focus the input<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","length":4770,"excerpt":"","more":"<p>用模拟数据写了一个作业管理的详情页，react可以用mock拦截前端发出去的请求，所以可以在这里放置模拟数据。<br>给了一个类似这样的界面：<br><img src=\"/blog/day2-react-learning-1.png\" alt=\"alt text\"></p>\n<h3 id=\"一、-页面结构设计\"><a href=\"#一、-页面结构设计\" class=\"headerlink\" title=\"一、 页面结构设计\"></a><strong>一、 页面结构设计</strong></h3><p>首先确定了把整个页面拆分成三个组件（上basicinfocard下documenttablecard），还有一个根组件jobdetail来负责获取jobid，管理整体的加载状态并组织子组件的渲染。</p>\n<ul>\n<li><code>BasicInfoCard</code>：用于展示顶部的基础信息。</li>\n<li><code>DocumentTableCard</code>：用于展示下方的文档列表。</li>\n<li><code>JobDetail</code>：作为根组件，负责从 URL 获取 <code>jobId</code>，管理整体的加载状态，并组织上述子组件的渲染。</li>\n</ul>\n<h3 id=\"二、-数据交互与状态管理\"><a href=\"#二、-数据交互与状态管理\" class=\"headerlink\" title=\"二、 数据交互与状态管理\"></a><strong>二、 数据交互与状态管理</strong></h3><p>接着是和后端的交互：</p>\n<h4 id=\"1-异步获取数据\"><a href=\"#1-异步获取数据\" class=\"headerlink\" title=\"1. 异步获取数据\"></a><strong>1. 异步获取数据</strong></h4><p>在 <code>JobDetail</code> 组件中，使用了 <code>useEffect</code> Hook。当组件首次加载或 <code>jobId</code> 变化时，它会自动调用 <code>service/job.ts</code> 中定义的接口函数 <code>getJobDocuments</code>，从后端异步获取文档列表数据。</p>\n<h4 id=\"2-存储和处理数据\"><a href=\"#2-存储和处理数据\" class=\"headerlink\" title=\"2. 存储和处理数据\"></a><strong>2. 存储和处理数据</strong></h4><ul>\n<li>使用useState创建dataSource状态，用于存储从后端获取的完整文档列表。获取到数据之后，对每条记录增加一个唯一的key属性来满足protable的要求。<br><em>protable功能确实挺丰富，部署起来也挺快捷的。这里先把它稍微进行了一下更改再拿来用，学习文档：<a href=\"https://procomponents.ant.design/components/table\">https://procomponents.ant.design/components/table</a></em></li>\n</ul>\n<h3 id=\"三、-ProTable-核心功能实现\"><a href=\"#三、-ProTable-核心功能实现\" class=\"headerlink\" title=\"三、 ProTable 核心功能实现\"></a><strong>三、 ProTable 核心功能实现</strong></h3><h4 id=\"1-行选择与批量下载\"><a href=\"#1-行选择与批量下载\" class=\"headerlink\" title=\"1. 行选择与批量下载\"></a><strong>1. 行选择与批量下载</strong></h4><pre><code>1. 创建了一个selectedRowKeys状态数组用来存放所有被勾选的行的key。\n2. 该列用render的方法返回一个&lt;Checkbox&gt;，其勾选状态与selectedRowKeys双向绑定。\n3. 该列的 title 属性也返回一个 &lt;Checkbox&gt;，作为“全选/取消全选”的控制器。其 checked 和 indeterminate (半选) 状态根据 selectedRowKeys 和 dataSource 的长度动态计算，实现了精确的全选逻辑。\n</code></pre>\n<h4 id=\"2-点击查看日志\"><a href=\"#2-点击查看日志\" class=\"headerlink\" title=\"2. 点击查看日志\"></a><strong>2. 点击查看日志</strong></h4><p>在名称列，将其渲染为一个<code>&lt;Button type=&quot;link&quot;&gt;</code>，使其外观像一个可点击的链接。点击后，通过更新 <code>logModalVisible</code> 状态来控制 <code>&lt;Modal&gt;</code> 弹窗的显示与隐藏，从而展示日志内容。</p>\n<h4 id=\"3-自定义搜索\"><a href=\"#3-自定义搜索\" class=\"headerlink\" title=\"3. 自定义搜索\"></a><strong>3. 自定义搜索</strong></h4><p>由于 ProTable 自带搜索的自定义空间有限，我选择实现一个自定义的搜索功能：</p>\n<ol>\n<li>在表格外部放置一个 <code>&lt;Input.Search&gt;</code> 组件。</li>\n<li>监听其 <code>onSearch</code> 事件，并将输入值更新到 <code>searchText</code> 状态。</li>\n<li>创建一个派生状态 <code>filteredDataSource</code>。它通过对原始 <code>dataSource</code> 数组使用 <code>.filter()</code> 方法，根据 <code>searchText</code> 的值进行客户端实时过滤。</li>\n<li>将 <code>ProTable</code> 的 <code>dataSource</code> 属性直接指向这个过滤后的 <code>filteredDataSource</code>，从而实现了自定义搜索。</li>\n</ol>\n<h3 id=\"四、-React-Hooks-学习总结\"><a href=\"#四、-React-Hooks-学习总结\" class=\"headerlink\" title=\"四、 React Hooks 学习总结\"></a><strong>四、 React Hooks 学习总结</strong></h3><h4 id=\"1-useState：组件的记忆\"><a href=\"#1-useState：组件的记忆\" class=\"headerlink\" title=\"1. useState：组件的记忆\"></a><strong>1. <code>useState</code>：组件的记忆</strong></h4><ul>\n<li>相当于内部记忆（可修改的便签纸），用于为函数组件添加状态。</li>\n<li>比如const [logModalVisible（便签纸）, setLogModalVisible（专用于修改便签纸的笔）] &#x3D; useState(false)，其中logModalVisible的状态就是false。我们可以并只能通过调用setLogModalVisible(true)来更新便签纸的状态。<ul>\n<li><strong>示例</strong>：  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Counter</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 声明一个名为 &quot;count&quot; 的 state 变量，初始化为 0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      &#123;/* 调用 setCount 来更新 state */&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">        Click me</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>与 <code>useParams</code> 的区别</strong>：相当于外部指令（门牌号），来自于网页的url地址，而不是内部的组件。它只能读取而无法控制。比如说const { jobId } &#x3D; useParams();就相当于看了一眼网页地址的门牌号，但是无法修改门牌。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-useEffect：处理副作用\"><a href=\"#2-useEffect：处理副作用\" class=\"headerlink\" title=\"2. useEffect：处理副作用\"></a><strong>2. <code>useEffect</code>：处理副作用</strong></h4><ul>\n<li><strong>作用</strong>：让函数组件能够在特定时机（如渲染后、依赖变化后）执行一些份外的事情（比如去服务器拿东西），例如数据获取、DOM 操作、设置订阅等。</li>\n<li><strong>类比</strong>：它是一条“如果…就…”的指令。<code>useEffect(() =&gt; &#123; fetchData(); &#125;, [jobId]);</code> 意味着：“如果 <code>jobId</code> 变了，就去服务器获取一次新数据”。</li>\n<li><strong>依赖数组说明</strong>：<ul>\n<li><code>[dep1, dep2]</code>: 依赖项 <code>dep1</code> 或 <code>dep2</code> 发生变化时执行。</li>\n<li><code>[]</code> (空数组): 只在组件<strong>首次挂载</strong>后执行一次。</li>\n<li><strong>不提供</strong>依赖数组: <strong>每次组件渲染后</strong>都会执行。<br>比如useEffect(() &#x3D;&gt; { fetchData(); }, [jobId]);<br>其中fetchData()意思是去服务器中拿回文件列表，jobid就是触发的ID（如果这个id发生了改变就去服务器拿回文件列表，但是如果还是同一个id的话就不需要跑一趟，用现有的就行。）<br>注意：①如果指令的触发条件是[]，意思即使开机后只执行一次以后都不管了；②如果没有触发条件，意思是任何一点风吹草动都要去执行这个指令。</li>\n</ul>\n</li>\n<li><strong>示例</strong>：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">UserInfo</span>(<span class=\"params\">&#123; userId &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [user, setUser] = <span class=\"title function_\">useState</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当 userId 变化时，执行这个副作用</span></span><br><span class=\"line\">    <span class=\"title function_\">fetch</span>(<span class=\"string\">`/api/users/<span class=\"subst\">$&#123;userId&#125;</span>`</span>)</span><br><span class=\"line\">      .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.<span class=\"title function_\">json</span>())</span><br><span class=\"line\">      .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> <span class=\"title function_\">setUser</span>(data));</span><br><span class=\"line\">  &#125;, [userId]); <span class=\"comment\">// 依赖项是 userId</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!user) <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Loading...&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;user.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"3-useContext：全局广播\"><a href=\"#3-useContext：全局广播\" class=\"headerlink\" title=\"3. useContext：全局广播\"></a><strong>3. <code>useContext</code>：全局广播</strong></h4><ul>\n<li>相当于公共广播系统。顶层组件可以通过广播发布信息，比如广播“当前主题：夜间模式”，那么所有组件（深层的也可以）只要打开收音机都会听到这个信息。</li>\n<li><strong>示例</strong>：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 创建 Context</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ThemeContext</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">createContext</span>(<span class=\"string\">&#x27;light&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在顶层组件使用 Provider 提供 value</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">ThemeContext.Provider</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;dark&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Toolbar</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">ThemeContext.Provider</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 在子组件中使用 useContext 消费 value</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ThemedButton</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> theme = <span class=\"title function_\">useContext</span>(<span class=\"title class_\">ThemeContext</span>); <span class=\"comment\">// theme 的值会是 &quot;dark&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;theme&#125;</span>&gt;</span>I am a &#123;theme&#125; button<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"4-useMemo：记住计算结果\"><a href=\"#4-useMemo：记住计算结果\" class=\"headerlink\" title=\"4. useMemo：记住计算结果\"></a><strong>4. <code>useMemo</code>：记住计算结果</strong></h4><ul>\n<li>用于记住一个复杂的计算结果（重在<strong>结果</strong>），避免重复计算。</li>\n<li><strong>示例</strong>：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ExpensiveComponent</span>(<span class=\"params\">&#123; list, filter &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 只有当 list 或 filter 变化时，才会重新执行 filter 操作</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> visibleList = <span class=\"title function_\">useMemo</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Filtering list...&#x27;</span>); <span class=\"comment\">// 这个 log 不会频繁触发</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> list.<span class=\"title function_\">filter</span>(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.<span class=\"title function_\">includes</span>(filter));</span><br><span class=\"line\">  &#125;, [list, filter]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;/* ... render visibleList ... */&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"5-useCallback：记住函数本身\"><a href=\"#5-useCallback：记住函数本身\" class=\"headerlink\" title=\"5. useCallback：记住函数本身\"></a><strong>5. <code>useCallback</code>：记住函数本身</strong></h4><p>用于记住一个计算公式（重在<strong>函数实例</strong>）。这在传递给子组件时非常有用。</p>\n<ul>\n<li><strong>示例</strong>：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Parent</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 使用 useCallback，这个 handleClick 函数实例在重渲染时保持不变</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> handleClick = <span class=\"title function_\">useCallback</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Button clicked!&#x27;</span>);</span><br><span class=\"line\">  &#125;, []); <span class=\"comment\">// 空依赖数组意味着函数永不改变</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Child</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;handleClick&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// React.memo 可以防止在 props 不变时重渲染子组件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Child</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">memo</span>(<span class=\"function\">(<span class=\"params\">&#123; onClick &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Child rendered&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;onClick&#125;</span>&gt;</span>Click me<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"6-useRef：多功能工具箱\"><a href=\"#6-useRef：多功能工具箱\" class=\"headerlink\" title=\"6. useRef：多功能工具箱\"></a><strong>6. <code>useRef</code>：多功能工具箱</strong></h4><ul>\n<li>相当于多功能工具箱，无论怎么刷新箱子里的东西都是同一个不会丢失。修改箱子里的东西也不会触发重新渲染。</li>\n<li><strong>作用</strong>：返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数。它可以在多次渲染之间保持不变。</li>\n<li><strong>特点</strong>：修改 <code>ref.current</code> <strong>不会</strong>触发组件的重新渲染。</li>\n<li><strong>常见用途</strong>：<ol>\n<li><strong>访问 DOM 元素</strong>：直接操作 DOM，如聚焦输入框。</li>\n<li><strong>存储可变值</strong>：存储一个与渲染无关的值，类似于实例变量。</li>\n</ol>\n</li>\n<li><strong>示例</strong>：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">TextInputWithFocusButton</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> inputEl = <span class=\"title function_\">useRef</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">onButtonClick</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// `current` 指向已挂载到 DOM 上的 text input 元素</span></span><br><span class=\"line\">    inputEl.<span class=\"property\">current</span>.<span class=\"title function_\">focus</span>();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">ref</span>=<span class=\"string\">&#123;inputEl&#125;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;onButtonClick&#125;</span>&gt;</span>Focus the input<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"hexo blog部署记录","date":"2025-04-12T08:00:00.000Z","_content":"2025年4月28日，第一次尝试把hexo集成到个人主页中，记录一下部署过程，以及后期的更新和测试步骤。\n\n## 部署过程\n\n### 创建hexo项目\n\nhexo是github上一个开源的博客模板，首先可以在新目录下创建一个hexo项目，然后进入该目录，执行如下命令：\n\n``` bash\n$ npm install -g hexo-cli\n```\n\n接着进行一个初始化，进行初始化之后会创建一个新的hexo项目，自动克隆hexo-start和landscape主题：\n\n``` bash\n$ hexo init myblog\n$ cd myblog\n$ npm install\n```\n初始化之后，项目文件夹如下所示：\n.\n├── _config.yml（网站配置文件，以下的修改调整主要在这个文件下进行）\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n\n\n### 本地测试\n默认地址是http://localhost:4000/\n``` bash\n$ hexo server\n```\n\n### 选择主题\n   \nhexo默认的主题比较简约，但它提供了非常多的模板，在https://hexo.io/themes/上可以挑选主题，我这里用的是vivia（https://github.com/saicaca/hexo-theme-vivia）。接着按README步骤安装执行即可。\n\n### 部署到github pages上\n#### 1.部署个人网站\n\n首先需要确认github上已有<username>.github.io的仓库，用于存放个人主页的代码。这里对创建过程进行一个简单的介绍：\n把个人主页网站的所有代码copy到一个本地的新文件夹下，然后再在github上新建一个仓库（命名为<username>.github.io,比如我的username是kkzyu），接着在本地文件夹中执行如下命令：\n\n``` bash\n$ git remote add origin git@github.com:kkzyu/kkzyu.github.io.git\n$ git branch -M main\n$ git push -u origin main\n```\n\npush成功后，进入setting->pages->branch，选择main和root，点击save。等待十分钟之后即可在https://kkzyu.github.io/查看自己的个人主页。\n\n#### 2.部署博客\n\n首先需要编辑myblog/_config.yml文件，修改/增加如下代码：\n    \n``` yaml\n# 部署配置\ndeploy:\n  type: git\n  repo: https://github.com/kkzyu/blog.git \n  branch: gh-pages  # 必须使用 gh-pages 分支\n  message: \"更新博客：{{ now('YYYY-MM-DD HH:mm:ss') }}\"\n\n# URL 设置\nurl: https://kkzyu.github.io/blog\nroot: /blog/\n```\n\n由于hexo博客和个人主页独立部署更优（少冲突），因此在github上新建一个仓库（可以命名为myblog），注意无需初始化readme或其他文件。创建完成后，同样需要将本地的仓库推送上去：\n\n``` bash\n$ git remote add origin git@github.com:kkzyu/myblog.git\n$ git branch -M main\n$ git push -u origin main\n```  \n\n接着在本地myblog文件夹下安装部署插件并部署：\n\n``` bash\n$ npm install hexo-deployer-git --save\n$ hexo clean && hexo generate && hexo deploy\n```\n\n接着进入myblog仓库的settings->pages，选择branch为gh-pages，选择root目录。之后等待几分钟，进入到https://kkzyu.github.io/blog/，即可看到自己的博客。\n\n### 将博客集成到vue个人主页中\n\n在vue项目中，修改路由配置(router/index.js)：\n\n``` js\nconst routes = [{\n    path: '/blog',\n    name: 'Blog',\n    beforeEnter() {\n      window.open('https://kkzyu.github.io/blog/', '_blank')\n      // 或者不新开标签页：\n      // window.location.href = 'https://kkzyu.github.io/blog/'\n    }\n  }]\n```\n\n在APP.vue中添加博客链接：\n\n``` vue\n<router-link to=\"/blog\">Blog</router-link>\n```\n\n等待几分钟之后，即可在vue项目中看到博客链接，点击后会在新标签页打开博客。\n\n## 后期更新和测试\n### 更新博客\n\n在本地对myblog进行了修改后，网页并不会自动更新，需要进行一下操作才可在网页中观察到更新后内容：\n\n``` bash\nnpx hexo clean\nnpx hexo generate\nnpx hexo deploy\n#可选：将源码变更推送到main分支备份\ngit add .\ngit commit -m \"更新博客内容\"\ngit push origin main\n```\n\n如果想要现在本地进行测试可以执行：\n\n``` bash\n$ hexo server\n```\n\n待测试成功后，再进行更新。","source":"_posts/hello-world.md","raw":"---\ntitle: hexo blog部署记录\ndate: 2025-04-12 16:00:00\ntags: web前端\n\n---\n2025年4月28日，第一次尝试把hexo集成到个人主页中，记录一下部署过程，以及后期的更新和测试步骤。\n\n## 部署过程\n\n### 创建hexo项目\n\nhexo是github上一个开源的博客模板，首先可以在新目录下创建一个hexo项目，然后进入该目录，执行如下命令：\n\n``` bash\n$ npm install -g hexo-cli\n```\n\n接着进行一个初始化，进行初始化之后会创建一个新的hexo项目，自动克隆hexo-start和landscape主题：\n\n``` bash\n$ hexo init myblog\n$ cd myblog\n$ npm install\n```\n初始化之后，项目文件夹如下所示：\n.\n├── _config.yml（网站配置文件，以下的修改调整主要在这个文件下进行）\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n\n\n### 本地测试\n默认地址是http://localhost:4000/\n``` bash\n$ hexo server\n```\n\n### 选择主题\n   \nhexo默认的主题比较简约，但它提供了非常多的模板，在https://hexo.io/themes/上可以挑选主题，我这里用的是vivia（https://github.com/saicaca/hexo-theme-vivia）。接着按README步骤安装执行即可。\n\n### 部署到github pages上\n#### 1.部署个人网站\n\n首先需要确认github上已有<username>.github.io的仓库，用于存放个人主页的代码。这里对创建过程进行一个简单的介绍：\n把个人主页网站的所有代码copy到一个本地的新文件夹下，然后再在github上新建一个仓库（命名为<username>.github.io,比如我的username是kkzyu），接着在本地文件夹中执行如下命令：\n\n``` bash\n$ git remote add origin git@github.com:kkzyu/kkzyu.github.io.git\n$ git branch -M main\n$ git push -u origin main\n```\n\npush成功后，进入setting->pages->branch，选择main和root，点击save。等待十分钟之后即可在https://kkzyu.github.io/查看自己的个人主页。\n\n#### 2.部署博客\n\n首先需要编辑myblog/_config.yml文件，修改/增加如下代码：\n    \n``` yaml\n# 部署配置\ndeploy:\n  type: git\n  repo: https://github.com/kkzyu/blog.git \n  branch: gh-pages  # 必须使用 gh-pages 分支\n  message: \"更新博客：{{ now('YYYY-MM-DD HH:mm:ss') }}\"\n\n# URL 设置\nurl: https://kkzyu.github.io/blog\nroot: /blog/\n```\n\n由于hexo博客和个人主页独立部署更优（少冲突），因此在github上新建一个仓库（可以命名为myblog），注意无需初始化readme或其他文件。创建完成后，同样需要将本地的仓库推送上去：\n\n``` bash\n$ git remote add origin git@github.com:kkzyu/myblog.git\n$ git branch -M main\n$ git push -u origin main\n```  \n\n接着在本地myblog文件夹下安装部署插件并部署：\n\n``` bash\n$ npm install hexo-deployer-git --save\n$ hexo clean && hexo generate && hexo deploy\n```\n\n接着进入myblog仓库的settings->pages，选择branch为gh-pages，选择root目录。之后等待几分钟，进入到https://kkzyu.github.io/blog/，即可看到自己的博客。\n\n### 将博客集成到vue个人主页中\n\n在vue项目中，修改路由配置(router/index.js)：\n\n``` js\nconst routes = [{\n    path: '/blog',\n    name: 'Blog',\n    beforeEnter() {\n      window.open('https://kkzyu.github.io/blog/', '_blank')\n      // 或者不新开标签页：\n      // window.location.href = 'https://kkzyu.github.io/blog/'\n    }\n  }]\n```\n\n在APP.vue中添加博客链接：\n\n``` vue\n<router-link to=\"/blog\">Blog</router-link>\n```\n\n等待几分钟之后，即可在vue项目中看到博客链接，点击后会在新标签页打开博客。\n\n## 后期更新和测试\n### 更新博客\n\n在本地对myblog进行了修改后，网页并不会自动更新，需要进行一下操作才可在网页中观察到更新后内容：\n\n``` bash\nnpx hexo clean\nnpx hexo generate\nnpx hexo deploy\n#可选：将源码变更推送到main分支备份\ngit add .\ngit commit -m \"更新博客内容\"\ngit push origin main\n```\n\n如果想要现在本地进行测试可以执行：\n\n``` bash\n$ hexo server\n```\n\n待测试成功后，再进行更新。","slug":"hello-world","published":1,"updated":"2025-07-09T03:31:34.957Z","comments":1,"layout":"post","photos":[],"_id":"cmd15y0wc0006lstv4mfk905s","content":"<p>2025年4月28日，第一次尝试把hexo集成到个人主页中，记录一下部署过程，以及后期的更新和测试步骤。</p>\n<h2 id=\"部署过程\"><a href=\"#部署过程\" class=\"headerlink\" title=\"部署过程\"></a>部署过程</h2><h3 id=\"创建hexo项目\"><a href=\"#创建hexo项目\" class=\"headerlink\" title=\"创建hexo项目\"></a>创建hexo项目</h3><p>hexo是github上一个开源的博客模板，首先可以在新目录下创建一个hexo项目，然后进入该目录，执行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>接着进行一个初始化，进行初始化之后会创建一个新的hexo项目，自动克隆hexo-start和landscape主题：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init myblog</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> myblog</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<p>初始化之后，项目文件夹如下所示：<br>.<br>├── _config.yml（网站配置文件，以下的修改调整主要在这个文件下进行）<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes</p>\n<h3 id=\"本地测试\"><a href=\"#本地测试\" class=\"headerlink\" title=\"本地测试\"></a>本地测试</h3><p>默认地址是<a href=\"http://localhost:4000/\">http://localhost:4000/</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"选择主题\"><a href=\"#选择主题\" class=\"headerlink\" title=\"选择主题\"></a>选择主题</h3><p>hexo默认的主题比较简约，但它提供了非常多的模板，在<a href=\"https://hexo.io/themes/%E4%B8%8A%E5%8F%AF%E4%BB%A5%E6%8C%91%E9%80%89%E4%B8%BB%E9%A2%98%EF%BC%8C%E6%88%91%E8%BF%99%E9%87%8C%E7%94%A8%E7%9A%84%E6%98%AFvivia%EF%BC%88https://github.com/saicaca/hexo-theme-vivia%EF%BC%89%E3%80%82%E6%8E%A5%E7%9D%80%E6%8C%89README%E6%AD%A5%E9%AA%A4%E5%AE%89%E8%A3%85%E6%89%A7%E8%A1%8C%E5%8D%B3%E5%8F%AF%E3%80%82\">https://hexo.io/themes/上可以挑选主题，我这里用的是vivia（https://github.com/saicaca/hexo-theme-vivia）。接着按README步骤安装执行即可。</a></p>\n<h3 id=\"部署到github-pages上\"><a href=\"#部署到github-pages上\" class=\"headerlink\" title=\"部署到github pages上\"></a>部署到github pages上</h3><h4 id=\"1-部署个人网站\"><a href=\"#1-部署个人网站\" class=\"headerlink\" title=\"1.部署个人网站\"></a>1.部署个人网站</h4><p>首先需要确认github上已有<username>.github.io的仓库，用于存放个人主页的代码。这里对创建过程进行一个简单的介绍：<br>把个人主页网站的所有代码copy到一个本地的新文件夹下，然后再在github上新建一个仓库（命名为<username>.github.io,比如我的username是kkzyu），接着在本地文件夹中执行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add origin git@github.com:kkzyu/kkzyu.github.io.git</span><br><span class=\"line\">$ git branch -M main</span><br><span class=\"line\">$ git push -u origin main</span><br></pre></td></tr></table></figure>\n\n<p>push成功后，进入setting-&gt;pages-&gt;branch，选择main和root，点击save。等待十分钟之后即可在<a href=\"https://kkzyu.github.io/%E6%9F%A5%E7%9C%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E3%80%82\">https://kkzyu.github.io/查看自己的个人主页。</a></p>\n<h4 id=\"2-部署博客\"><a href=\"#2-部署博客\" class=\"headerlink\" title=\"2.部署博客\"></a>2.部署博客</h4><p>首先需要编辑myblog&#x2F;_config.yml文件，修改&#x2F;增加如下代码：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 部署配置</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">https://github.com/kkzyu/blog.git</span> </span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">gh-pages</span>  <span class=\"comment\"># 必须使用 gh-pages 分支</span></span><br><span class=\"line\">  <span class=\"attr\">message:</span> <span class=\"string\">&quot;更新博客：<span class=\"template-variable\">&#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125;</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># URL 设置</span></span><br><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"string\">https://kkzyu.github.io/blog</span></span><br><span class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">/blog/</span></span><br></pre></td></tr></table></figure>\n\n<p>由于hexo博客和个人主页独立部署更优（少冲突），因此在github上新建一个仓库（可以命名为myblog），注意无需初始化readme或其他文件。创建完成后，同样需要将本地的仓库推送上去：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add origin git@github.com:kkzyu/myblog.git</span><br><span class=\"line\">$ git branch -M main</span><br><span class=\"line\">$ git push -u origin main</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">接着在本地myblog文件夹下安装部署插件并部署：</span><br><span class=\"line\"></span><br><span class=\"line\">``` bash</span><br><span class=\"line\">$ npm install hexo-deployer-git --save</span><br><span class=\"line\">$ hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>接着进入myblog仓库的settings-&gt;pages，选择branch为gh-pages，选择root目录。之后等待几分钟，进入到<a href=\"https://kkzyu.github.io/blog/%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E3%80%82\">https://kkzyu.github.io/blog/，即可看到自己的博客。</a></p>\n<h3 id=\"将博客集成到vue个人主页中\"><a href=\"#将博客集成到vue个人主页中\" class=\"headerlink\" title=\"将博客集成到vue个人主页中\"></a>将博客集成到vue个人主页中</h3><p>在vue项目中，修改路由配置(router&#x2F;index.js)：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> routes = [&#123;</span><br><span class=\"line\">    <span class=\"attr\">path</span>: <span class=\"string\">&#x27;/blog&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Blog&#x27;</span>,</span><br><span class=\"line\">    <span class=\"title function_\">beforeEnter</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">window</span>.<span class=\"title function_\">open</span>(<span class=\"string\">&#x27;https://kkzyu.github.io/blog/&#x27;</span>, <span class=\"string\">&#x27;_blank&#x27;</span>)</span><br><span class=\"line\">      <span class=\"comment\">// 或者不新开标签页：</span></span><br><span class=\"line\">      <span class=\"comment\">// window.location.href = &#x27;https://kkzyu.github.io/blog/&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;]</span><br></pre></td></tr></table></figure>\n\n<p>在APP.vue中添加博客链接：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link to=&quot;/blog&quot;&gt;Blog&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>\n\n<p>等待几分钟之后，即可在vue项目中看到博客链接，点击后会在新标签页打开博客。</p>\n<h2 id=\"后期更新和测试\"><a href=\"#后期更新和测试\" class=\"headerlink\" title=\"后期更新和测试\"></a>后期更新和测试</h2><h3 id=\"更新博客\"><a href=\"#更新博客\" class=\"headerlink\" title=\"更新博客\"></a>更新博客</h3><p>在本地对myblog进行了修改后，网页并不会自动更新，需要进行一下操作才可在网页中观察到更新后内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hexo clean</span><br><span class=\"line\">npx hexo generate</span><br><span class=\"line\">npx hexo deploy</span><br><span class=\"line\"><span class=\"comment\">#可选：将源码变更推送到main分支备份</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;更新博客内容&quot;</span></span><br><span class=\"line\">git push origin main</span><br></pre></td></tr></table></figure>\n\n<p>如果想要现在本地进行测试可以执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>待测试成功后，再进行更新。</p>\n","length":2272,"excerpt":"","more":"<p>2025年4月28日，第一次尝试把hexo集成到个人主页中，记录一下部署过程，以及后期的更新和测试步骤。</p>\n<h2 id=\"部署过程\"><a href=\"#部署过程\" class=\"headerlink\" title=\"部署过程\"></a>部署过程</h2><h3 id=\"创建hexo项目\"><a href=\"#创建hexo项目\" class=\"headerlink\" title=\"创建hexo项目\"></a>创建hexo项目</h3><p>hexo是github上一个开源的博客模板，首先可以在新目录下创建一个hexo项目，然后进入该目录，执行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>接着进行一个初始化，进行初始化之后会创建一个新的hexo项目，自动克隆hexo-start和landscape主题：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init myblog</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> myblog</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<p>初始化之后，项目文件夹如下所示：<br>.<br>├── _config.yml（网站配置文件，以下的修改调整主要在这个文件下进行）<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes</p>\n<h3 id=\"本地测试\"><a href=\"#本地测试\" class=\"headerlink\" title=\"本地测试\"></a>本地测试</h3><p>默认地址是<a href=\"http://localhost:4000/\">http://localhost:4000/</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"选择主题\"><a href=\"#选择主题\" class=\"headerlink\" title=\"选择主题\"></a>选择主题</h3><p>hexo默认的主题比较简约，但它提供了非常多的模板，在<a href=\"https://hexo.io/themes/%E4%B8%8A%E5%8F%AF%E4%BB%A5%E6%8C%91%E9%80%89%E4%B8%BB%E9%A2%98%EF%BC%8C%E6%88%91%E8%BF%99%E9%87%8C%E7%94%A8%E7%9A%84%E6%98%AFvivia%EF%BC%88https://github.com/saicaca/hexo-theme-vivia%EF%BC%89%E3%80%82%E6%8E%A5%E7%9D%80%E6%8C%89README%E6%AD%A5%E9%AA%A4%E5%AE%89%E8%A3%85%E6%89%A7%E8%A1%8C%E5%8D%B3%E5%8F%AF%E3%80%82\">https://hexo.io/themes/上可以挑选主题，我这里用的是vivia（https://github.com/saicaca/hexo-theme-vivia）。接着按README步骤安装执行即可。</a></p>\n<h3 id=\"部署到github-pages上\"><a href=\"#部署到github-pages上\" class=\"headerlink\" title=\"部署到github pages上\"></a>部署到github pages上</h3><h4 id=\"1-部署个人网站\"><a href=\"#1-部署个人网站\" class=\"headerlink\" title=\"1.部署个人网站\"></a>1.部署个人网站</h4><p>首先需要确认github上已有<username>.github.io的仓库，用于存放个人主页的代码。这里对创建过程进行一个简单的介绍：<br>把个人主页网站的所有代码copy到一个本地的新文件夹下，然后再在github上新建一个仓库（命名为<username>.github.io,比如我的username是kkzyu），接着在本地文件夹中执行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add origin git@github.com:kkzyu/kkzyu.github.io.git</span><br><span class=\"line\">$ git branch -M main</span><br><span class=\"line\">$ git push -u origin main</span><br></pre></td></tr></table></figure>\n\n<p>push成功后，进入setting-&gt;pages-&gt;branch，选择main和root，点击save。等待十分钟之后即可在<a href=\"https://kkzyu.github.io/%E6%9F%A5%E7%9C%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E3%80%82\">https://kkzyu.github.io/查看自己的个人主页。</a></p>\n<h4 id=\"2-部署博客\"><a href=\"#2-部署博客\" class=\"headerlink\" title=\"2.部署博客\"></a>2.部署博客</h4><p>首先需要编辑myblog&#x2F;_config.yml文件，修改&#x2F;增加如下代码：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 部署配置</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">https://github.com/kkzyu/blog.git</span> </span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">gh-pages</span>  <span class=\"comment\"># 必须使用 gh-pages 分支</span></span><br><span class=\"line\">  <span class=\"attr\">message:</span> <span class=\"string\">&quot;更新博客：<span class=\"template-variable\">&#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125;</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># URL 设置</span></span><br><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"string\">https://kkzyu.github.io/blog</span></span><br><span class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">/blog/</span></span><br></pre></td></tr></table></figure>\n\n<p>由于hexo博客和个人主页独立部署更优（少冲突），因此在github上新建一个仓库（可以命名为myblog），注意无需初始化readme或其他文件。创建完成后，同样需要将本地的仓库推送上去：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add origin git@github.com:kkzyu/myblog.git</span><br><span class=\"line\">$ git branch -M main</span><br><span class=\"line\">$ git push -u origin main</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">接着在本地myblog文件夹下安装部署插件并部署：</span><br><span class=\"line\"></span><br><span class=\"line\">``` bash</span><br><span class=\"line\">$ npm install hexo-deployer-git --save</span><br><span class=\"line\">$ hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>接着进入myblog仓库的settings-&gt;pages，选择branch为gh-pages，选择root目录。之后等待几分钟，进入到<a href=\"https://kkzyu.github.io/blog/%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E3%80%82\">https://kkzyu.github.io/blog/，即可看到自己的博客。</a></p>\n<h3 id=\"将博客集成到vue个人主页中\"><a href=\"#将博客集成到vue个人主页中\" class=\"headerlink\" title=\"将博客集成到vue个人主页中\"></a>将博客集成到vue个人主页中</h3><p>在vue项目中，修改路由配置(router&#x2F;index.js)：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> routes = [&#123;</span><br><span class=\"line\">    <span class=\"attr\">path</span>: <span class=\"string\">&#x27;/blog&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Blog&#x27;</span>,</span><br><span class=\"line\">    <span class=\"title function_\">beforeEnter</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">window</span>.<span class=\"title function_\">open</span>(<span class=\"string\">&#x27;https://kkzyu.github.io/blog/&#x27;</span>, <span class=\"string\">&#x27;_blank&#x27;</span>)</span><br><span class=\"line\">      <span class=\"comment\">// 或者不新开标签页：</span></span><br><span class=\"line\">      <span class=\"comment\">// window.location.href = &#x27;https://kkzyu.github.io/blog/&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;]</span><br></pre></td></tr></table></figure>\n\n<p>在APP.vue中添加博客链接：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link to=&quot;/blog&quot;&gt;Blog&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>\n\n<p>等待几分钟之后，即可在vue项目中看到博客链接，点击后会在新标签页打开博客。</p>\n<h2 id=\"后期更新和测试\"><a href=\"#后期更新和测试\" class=\"headerlink\" title=\"后期更新和测试\"></a>后期更新和测试</h2><h3 id=\"更新博客\"><a href=\"#更新博客\" class=\"headerlink\" title=\"更新博客\"></a>更新博客</h3><p>在本地对myblog进行了修改后，网页并不会自动更新，需要进行一下操作才可在网页中观察到更新后内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hexo clean</span><br><span class=\"line\">npx hexo generate</span><br><span class=\"line\">npx hexo deploy</span><br><span class=\"line\"><span class=\"comment\">#可选：将源码变更推送到main分支备份</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;更新博客内容&quot;</span></span><br><span class=\"line\">git push origin main</span><br></pre></td></tr></table></figure>\n\n<p>如果想要现在本地进行测试可以执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>待测试成功后，再进行更新。</p>\n"},{"title":"pinia重构","date":"2025-04-28T14:05:46.000Z","_content":"### Pinia 重构过程记录\n#### 重构步骤\n\n1. 安装必要依赖\n```bash\nnpm install pinia\n```\n\n2. 创建 Pinia Store\n```js\n// stores/cvStore.js\nimport { defineStore } from 'pinia'\nimport { message } from 'ant-design-vue'\nimport cvDataStructure from '@/assets/data/cv-info.json'\nimport html2canvas from 'html2canvas'\nimport jsPDF from 'jspdf'\n\nexport const useCvStore = defineStore('cv', {\n  state: () => ({\n    currentLang: 'cn',\n    activeSections: [],\n    commentContent: '',\n    isDownloadingPdf: false,\n    defaultAvatar: '/images/kkz.jpg',\n    manualToggleStates: {}\n  }),\n  \n  actions: {\n    // 业务逻辑方法...\n  },\n  \n  getters: {\n    // 计算属性...\n  }\n})\n```\n\n3. 修改组件结构\n```vue\n<script setup>\nimport { storeToRefs } from 'pinia'\nimport { useCvStore } from '@/stores/cvStore'\n\nconst store = useCvStore()\nconst { \n  currentLang,\n  activeSections,\n  isDownloadingPdf,\n  cvData\n} = storeToRefs(store)\n\n// 方法代理\nconst handleLangChange = ({ key }) => store.handleLangChange(key)\nconst downloadPDF = () => store.downloadPDF(cvContainerRef.value)\n</script>\n```\n","source":"_posts/pinia重构.md","raw":"---\ntitle: pinia重构\ndate: 2025-04-28 22:05:46\ntags: web前端\n\n---\n### Pinia 重构过程记录\n#### 重构步骤\n\n1. 安装必要依赖\n```bash\nnpm install pinia\n```\n\n2. 创建 Pinia Store\n```js\n// stores/cvStore.js\nimport { defineStore } from 'pinia'\nimport { message } from 'ant-design-vue'\nimport cvDataStructure from '@/assets/data/cv-info.json'\nimport html2canvas from 'html2canvas'\nimport jsPDF from 'jspdf'\n\nexport const useCvStore = defineStore('cv', {\n  state: () => ({\n    currentLang: 'cn',\n    activeSections: [],\n    commentContent: '',\n    isDownloadingPdf: false,\n    defaultAvatar: '/images/kkz.jpg',\n    manualToggleStates: {}\n  }),\n  \n  actions: {\n    // 业务逻辑方法...\n  },\n  \n  getters: {\n    // 计算属性...\n  }\n})\n```\n\n3. 修改组件结构\n```vue\n<script setup>\nimport { storeToRefs } from 'pinia'\nimport { useCvStore } from '@/stores/cvStore'\n\nconst store = useCvStore()\nconst { \n  currentLang,\n  activeSections,\n  isDownloadingPdf,\n  cvData\n} = storeToRefs(store)\n\n// 方法代理\nconst handleLangChange = ({ key }) => store.handleLangChange(key)\nconst downloadPDF = () => store.downloadPDF(cvContainerRef.value)\n</script>\n```\n","slug":"pinia重构","published":1,"updated":"2025-07-08T01:44:29.143Z","comments":1,"layout":"post","photos":[],"_id":"cmd15y0wk000slstv7lbmar7v","content":"<h3 id=\"Pinia-重构过程记录\"><a href=\"#Pinia-重构过程记录\" class=\"headerlink\" title=\"Pinia 重构过程记录\"></a>Pinia 重构过程记录</h3><h4 id=\"重构步骤\"><a href=\"#重构步骤\" class=\"headerlink\" title=\"重构步骤\"></a>重构步骤</h4><ol>\n<li><p>安装必要依赖</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install pinia</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建 Pinia Store</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// stores/cvStore.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; defineStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;pinia&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; message &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;ant-design-vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> cvDataStructure <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@/assets/data/cv-info.json&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> html2canvas <span class=\"keyword\">from</span> <span class=\"string\">&#x27;html2canvas&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> jsPDF <span class=\"keyword\">from</span> <span class=\"string\">&#x27;jspdf&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> useCvStore = <span class=\"title function_\">defineStore</span>(<span class=\"string\">&#x27;cv&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: <span class=\"function\">() =&gt;</span> (&#123;</span><br><span class=\"line\">    <span class=\"attr\">currentLang</span>: <span class=\"string\">&#x27;cn&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">activeSections</span>: [],</span><br><span class=\"line\">    <span class=\"attr\">commentContent</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">isDownloadingPdf</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">defaultAvatar</span>: <span class=\"string\">&#x27;/images/kkz.jpg&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">manualToggleStates</span>: &#123;&#125;</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 业务逻辑方法...</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"attr\">getters</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算属性...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改组件结构</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">import &#123; storeToRefs &#125; from &#x27;pinia&#x27;</span><br><span class=\"line\">import &#123; useCvStore &#125; from &#x27;@/stores/cvStore&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">const store = useCvStore()</span><br><span class=\"line\">const &#123; </span><br><span class=\"line\">  currentLang,</span><br><span class=\"line\">  activeSections,</span><br><span class=\"line\">  isDownloadingPdf,</span><br><span class=\"line\">  cvData</span><br><span class=\"line\">&#125; = storeToRefs(store)</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法代理</span><br><span class=\"line\">const handleLangChange = (&#123; key &#125;) =&gt; store.handleLangChange(key)</span><br><span class=\"line\">const downloadPDF = () =&gt; store.downloadPDF(cvContainerRef.value)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n","length":1095,"excerpt":"","more":"<h3 id=\"Pinia-重构过程记录\"><a href=\"#Pinia-重构过程记录\" class=\"headerlink\" title=\"Pinia 重构过程记录\"></a>Pinia 重构过程记录</h3><h4 id=\"重构步骤\"><a href=\"#重构步骤\" class=\"headerlink\" title=\"重构步骤\"></a>重构步骤</h4><ol>\n<li><p>安装必要依赖</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install pinia</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建 Pinia Store</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// stores/cvStore.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; defineStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;pinia&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; message &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;ant-design-vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> cvDataStructure <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@/assets/data/cv-info.json&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> html2canvas <span class=\"keyword\">from</span> <span class=\"string\">&#x27;html2canvas&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> jsPDF <span class=\"keyword\">from</span> <span class=\"string\">&#x27;jspdf&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> useCvStore = <span class=\"title function_\">defineStore</span>(<span class=\"string\">&#x27;cv&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: <span class=\"function\">() =&gt;</span> (&#123;</span><br><span class=\"line\">    <span class=\"attr\">currentLang</span>: <span class=\"string\">&#x27;cn&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">activeSections</span>: [],</span><br><span class=\"line\">    <span class=\"attr\">commentContent</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">isDownloadingPdf</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">defaultAvatar</span>: <span class=\"string\">&#x27;/images/kkz.jpg&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">manualToggleStates</span>: &#123;&#125;</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 业务逻辑方法...</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"attr\">getters</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算属性...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改组件结构</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">import &#123; storeToRefs &#125; from &#x27;pinia&#x27;</span><br><span class=\"line\">import &#123; useCvStore &#125; from &#x27;@/stores/cvStore&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">const store = useCvStore()</span><br><span class=\"line\">const &#123; </span><br><span class=\"line\">  currentLang,</span><br><span class=\"line\">  activeSections,</span><br><span class=\"line\">  isDownloadingPdf,</span><br><span class=\"line\">  cvData</span><br><span class=\"line\">&#125; = storeToRefs(store)</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法代理</span><br><span class=\"line\">const handleLangChange = (&#123; key &#125;) =&gt; store.handleLangChange(key)</span><br><span class=\"line\">const downloadPDF = () =&gt; store.downloadPDF(cvContainerRef.value)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"github-actions","date":"2025-05-22T03:52:16.000Z","_content":"\n尝试了一下github的自动部署网站，进入actions后new一个workflow，添加以下代码并commit：\n\n```\nname: Deploy Vue Frontend\n\non:\n  push:\n    branches: [ \"main\" ]\n  workflow_dispatch: # 允许手动触发\n\n# 为 GITHUB_TOKEN 设置默认权限，以便部署到 GitHub Pages\npermissions:\n  contents: read      # checkout 代码需要\n  pages: write        # 部署到 GitHub Pages 需要\n  id-token: write     # OIDC 认证需要 (actions/deploy-pages 使用)\n\n# 只允许一个并发部署，跳过在队列中等待的运行。\n# 但是，不要取消进行中的运行，因为我们希望允许那些部署完成。\nconcurrency:\n  group: \"pages\"\n  cancel-in-progress: false\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: \"20\" # 或者你的项目使用的版本\n          cache: 'npm'\n          cache-dependency-path: client/package-lock.json # 更精确的缓存路径\n\n      - name: Install Dependencies\n        working-directory: ./client\n        run: npm ci # 使用 ci 更稳定\n\n      - name: Build\n        working-directory: ./client\n        run: npm run build # 确保你的 vite.config.js 中 base: '/仓库名/' 已设置\n\n      - name: Setup Pages\n        uses: actions/configure-pages@v4 # 官方action\n\n      - name: Upload artifact\n        uses: actions/upload-pages-artifact@v3 # 官方action\n        with:\n          # 从 client/dist 目录上传\n          path: './client/dist'\n\n  deploy:\n    needs: build # 依赖 build job\n    runs-on: ubuntu-latest\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }} # 输出部署后的 URL\n    steps:\n      - name: Deploy to GitHub Pages\n        id: deployment\n        uses: actions/deploy-pages@v4 # 官方action\n```\n\n在本地进行git pull后，在client目录下的vite.config.js里面添加这行代码base:'/{仓库名}/',package.json里面添加这行代码\"homepage\": \"https://kkzyu.github.io/{仓库名}\"。\n\n再到github的setting下进行以下操作：\n\n- pages下的source选择github actions；\n- environment下检查是否存在github-pages，点击进入查看是否有master这个分支；\n- actions的general下，勾选read and write permission以及Allow GitHub Actions to create and approve pull requests。\n\n\n\n在部署last1km的时候出现了很多路径上的问题，导致信息无法正常显示，这主要是因为在vite中把base改成了/last1km/后在解析的时候路径发生了变化，这也是写代码的时候不太规范导致的问题。\n\n以chatpage.vue为例，下面是对应的解决办法：\n\n```\n# 定义baseurl为vite下记录的url\nconst BASE_URL = import.meta.env.BASE_URL;\n# 由于在json文件里面保留了/对应的public路径，所以这里需要对路径格式进行修改，由于baseurl的last1km后面还跟着一个/，所以需要去掉其中的一个/\nconst resolveAssetPath = (relativePath) => {\n  if (!relativePath) return undefined;\n  let path = relativePath;\n  if (BASE_URL.endsWith('/') && path.startsWith('/')) {\n    path = path.substring(1);\n  } else if (!BASE_URL.endsWith('/') && !path.startsWith('/')) {\n  }\n  return `${BASE_URL}${path}`;\n};\n# 这个可以直接放到stores下用pinia管理，并导入\n# ......\n# 对应的在获取数据时也要进行以下更改\n    const fetchPath = 'data/messages.json'; // Path relative to public directory\n    const response = await fetch(`${BASE_URL}${fetchPath}`);\n    const riderData = currentChatData.rider ? {\n        ...currentChatData.rider,\n        // chatInfo.rider.avatar 的值如 \"/images/avatar1.jpg\"\n        // resolveAssetPath会处理它，变成 \"/last1km/images/avatar1.jpg\"\n        avatar: currentChatData.rider.avatar ? resolveAssetPath(currentChatData.rider.avatar) : undefined\n      } : null;\n```\n\n","source":"_posts/github-actions.md","raw":"---\ntitle: github-actions\ndate: 2025-05-22 11:52:16\ntags: [git, web前端]\n\n---\n\n尝试了一下github的自动部署网站，进入actions后new一个workflow，添加以下代码并commit：\n\n```\nname: Deploy Vue Frontend\n\non:\n  push:\n    branches: [ \"main\" ]\n  workflow_dispatch: # 允许手动触发\n\n# 为 GITHUB_TOKEN 设置默认权限，以便部署到 GitHub Pages\npermissions:\n  contents: read      # checkout 代码需要\n  pages: write        # 部署到 GitHub Pages 需要\n  id-token: write     # OIDC 认证需要 (actions/deploy-pages 使用)\n\n# 只允许一个并发部署，跳过在队列中等待的运行。\n# 但是，不要取消进行中的运行，因为我们希望允许那些部署完成。\nconcurrency:\n  group: \"pages\"\n  cancel-in-progress: false\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: \"20\" # 或者你的项目使用的版本\n          cache: 'npm'\n          cache-dependency-path: client/package-lock.json # 更精确的缓存路径\n\n      - name: Install Dependencies\n        working-directory: ./client\n        run: npm ci # 使用 ci 更稳定\n\n      - name: Build\n        working-directory: ./client\n        run: npm run build # 确保你的 vite.config.js 中 base: '/仓库名/' 已设置\n\n      - name: Setup Pages\n        uses: actions/configure-pages@v4 # 官方action\n\n      - name: Upload artifact\n        uses: actions/upload-pages-artifact@v3 # 官方action\n        with:\n          # 从 client/dist 目录上传\n          path: './client/dist'\n\n  deploy:\n    needs: build # 依赖 build job\n    runs-on: ubuntu-latest\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }} # 输出部署后的 URL\n    steps:\n      - name: Deploy to GitHub Pages\n        id: deployment\n        uses: actions/deploy-pages@v4 # 官方action\n```\n\n在本地进行git pull后，在client目录下的vite.config.js里面添加这行代码base:'/{仓库名}/',package.json里面添加这行代码\"homepage\": \"https://kkzyu.github.io/{仓库名}\"。\n\n再到github的setting下进行以下操作：\n\n- pages下的source选择github actions；\n- environment下检查是否存在github-pages，点击进入查看是否有master这个分支；\n- actions的general下，勾选read and write permission以及Allow GitHub Actions to create and approve pull requests。\n\n\n\n在部署last1km的时候出现了很多路径上的问题，导致信息无法正常显示，这主要是因为在vite中把base改成了/last1km/后在解析的时候路径发生了变化，这也是写代码的时候不太规范导致的问题。\n\n以chatpage.vue为例，下面是对应的解决办法：\n\n```\n# 定义baseurl为vite下记录的url\nconst BASE_URL = import.meta.env.BASE_URL;\n# 由于在json文件里面保留了/对应的public路径，所以这里需要对路径格式进行修改，由于baseurl的last1km后面还跟着一个/，所以需要去掉其中的一个/\nconst resolveAssetPath = (relativePath) => {\n  if (!relativePath) return undefined;\n  let path = relativePath;\n  if (BASE_URL.endsWith('/') && path.startsWith('/')) {\n    path = path.substring(1);\n  } else if (!BASE_URL.endsWith('/') && !path.startsWith('/')) {\n  }\n  return `${BASE_URL}${path}`;\n};\n# 这个可以直接放到stores下用pinia管理，并导入\n# ......\n# 对应的在获取数据时也要进行以下更改\n    const fetchPath = 'data/messages.json'; // Path relative to public directory\n    const response = await fetch(`${BASE_URL}${fetchPath}`);\n    const riderData = currentChatData.rider ? {\n        ...currentChatData.rider,\n        // chatInfo.rider.avatar 的值如 \"/images/avatar1.jpg\"\n        // resolveAssetPath会处理它，变成 \"/last1km/images/avatar1.jpg\"\n        avatar: currentChatData.rider.avatar ? resolveAssetPath(currentChatData.rider.avatar) : undefined\n      } : null;\n```\n\n","slug":"github-actions","published":1,"updated":"2025-07-08T01:44:29.143Z","comments":1,"layout":"post","photos":[],"_id":"cmd15y0wk000tlstv1rnh9n81","content":"<p>尝试了一下github的自动部署网站，进入actions后new一个workflow，添加以下代码并commit：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name: Deploy Vue Frontend</span><br><span class=\"line\"></span><br><span class=\"line\">on:</span><br><span class=\"line\">  push:</span><br><span class=\"line\">    branches: [ &quot;main&quot; ]</span><br><span class=\"line\">  workflow_dispatch: # 允许手动触发</span><br><span class=\"line\"></span><br><span class=\"line\"># 为 GITHUB_TOKEN 设置默认权限，以便部署到 GitHub Pages</span><br><span class=\"line\">permissions:</span><br><span class=\"line\">  contents: read      # checkout 代码需要</span><br><span class=\"line\">  pages: write        # 部署到 GitHub Pages 需要</span><br><span class=\"line\">  id-token: write     # OIDC 认证需要 (actions/deploy-pages 使用)</span><br><span class=\"line\"></span><br><span class=\"line\"># 只允许一个并发部署，跳过在队列中等待的运行。</span><br><span class=\"line\"># 但是，不要取消进行中的运行，因为我们希望允许那些部署完成。</span><br><span class=\"line\">concurrency:</span><br><span class=\"line\">  group: &quot;pages&quot;</span><br><span class=\"line\">  cancel-in-progress: false</span><br><span class=\"line\"></span><br><span class=\"line\">jobs:</span><br><span class=\"line\">  build:</span><br><span class=\"line\">    runs-on: ubuntu-latest</span><br><span class=\"line\">    steps:</span><br><span class=\"line\">      - name: Checkout</span><br><span class=\"line\">        uses: actions/checkout@v4</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Setup Node.js</span><br><span class=\"line\">        uses: actions/setup-node@v4</span><br><span class=\"line\">        with:</span><br><span class=\"line\">          node-version: &quot;20&quot; # 或者你的项目使用的版本</span><br><span class=\"line\">          cache: &#x27;npm&#x27;</span><br><span class=\"line\">          cache-dependency-path: client/package-lock.json # 更精确的缓存路径</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Install Dependencies</span><br><span class=\"line\">        working-directory: ./client</span><br><span class=\"line\">        run: npm ci # 使用 ci 更稳定</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Build</span><br><span class=\"line\">        working-directory: ./client</span><br><span class=\"line\">        run: npm run build # 确保你的 vite.config.js 中 base: &#x27;/仓库名/&#x27; 已设置</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Setup Pages</span><br><span class=\"line\">        uses: actions/configure-pages@v4 # 官方action</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Upload artifact</span><br><span class=\"line\">        uses: actions/upload-pages-artifact@v3 # 官方action</span><br><span class=\"line\">        with:</span><br><span class=\"line\">          # 从 client/dist 目录上传</span><br><span class=\"line\">          path: &#x27;./client/dist&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">  deploy:</span><br><span class=\"line\">    needs: build # 依赖 build job</span><br><span class=\"line\">    runs-on: ubuntu-latest</span><br><span class=\"line\">    environment:</span><br><span class=\"line\">      name: github-pages</span><br><span class=\"line\">      url: $&#123;&#123; steps.deployment.outputs.page_url &#125;&#125; # 输出部署后的 URL</span><br><span class=\"line\">    steps:</span><br><span class=\"line\">      - name: Deploy to GitHub Pages</span><br><span class=\"line\">        id: deployment</span><br><span class=\"line\">        uses: actions/deploy-pages@v4 # 官方action</span><br></pre></td></tr></table></figure>\n\n<p>在本地进行git pull后，在client目录下的vite.config.js里面添加这行代码base:’&#x2F;{仓库名}&#x2F;‘,package.json里面添加这行代码”homepage”: “<a href=\"https://kkzyu.github.io/%7B%E4%BB%93%E5%BA%93%E5%90%8D%7D%22%E3%80%82\">https://kkzyu.github.io/{仓库名}&quot;。</a></p>\n<p>再到github的setting下进行以下操作：</p>\n<ul>\n<li>pages下的source选择github actions；</li>\n<li>environment下检查是否存在github-pages，点击进入查看是否有master这个分支；</li>\n<li>actions的general下，勾选read and write permission以及Allow GitHub Actions to create and approve pull requests。</li>\n</ul>\n<p>在部署last1km的时候出现了很多路径上的问题，导致信息无法正常显示，这主要是因为在vite中把base改成了&#x2F;last1km&#x2F;后在解析的时候路径发生了变化，这也是写代码的时候不太规范导致的问题。</p>\n<p>以chatpage.vue为例，下面是对应的解决办法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 定义baseurl为vite下记录的url</span><br><span class=\"line\">const BASE_URL = import.meta.env.BASE_URL;</span><br><span class=\"line\"># 由于在json文件里面保留了/对应的public路径，所以这里需要对路径格式进行修改，由于baseurl的last1km后面还跟着一个/，所以需要去掉其中的一个/</span><br><span class=\"line\">const resolveAssetPath = (relativePath) =&gt; &#123;</span><br><span class=\"line\">  if (!relativePath) return undefined;</span><br><span class=\"line\">  let path = relativePath;</span><br><span class=\"line\">  if (BASE_URL.endsWith(&#x27;/&#x27;) &amp;&amp; path.startsWith(&#x27;/&#x27;)) &#123;</span><br><span class=\"line\">    path = path.substring(1);</span><br><span class=\"line\">  &#125; else if (!BASE_URL.endsWith(&#x27;/&#x27;) &amp;&amp; !path.startsWith(&#x27;/&#x27;)) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return `$&#123;BASE_URL&#125;$&#123;path&#125;`;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"># 这个可以直接放到stores下用pinia管理，并导入</span><br><span class=\"line\"># ......</span><br><span class=\"line\"># 对应的在获取数据时也要进行以下更改</span><br><span class=\"line\">    const fetchPath = &#x27;data/messages.json&#x27;; // Path relative to public directory</span><br><span class=\"line\">    const response = await fetch(`$&#123;BASE_URL&#125;$&#123;fetchPath&#125;`);</span><br><span class=\"line\">    const riderData = currentChatData.rider ? &#123;</span><br><span class=\"line\">        ...currentChatData.rider,</span><br><span class=\"line\">        // chatInfo.rider.avatar 的值如 &quot;/images/avatar1.jpg&quot;</span><br><span class=\"line\">        // resolveAssetPath会处理它，变成 &quot;/last1km/images/avatar1.jpg&quot;</span><br><span class=\"line\">        avatar: currentChatData.rider.avatar ? resolveAssetPath(currentChatData.rider.avatar) : undefined</span><br><span class=\"line\">      &#125; : null;</span><br></pre></td></tr></table></figure>\n\n","length":2830,"excerpt":"","more":"<p>尝试了一下github的自动部署网站，进入actions后new一个workflow，添加以下代码并commit：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name: Deploy Vue Frontend</span><br><span class=\"line\"></span><br><span class=\"line\">on:</span><br><span class=\"line\">  push:</span><br><span class=\"line\">    branches: [ &quot;main&quot; ]</span><br><span class=\"line\">  workflow_dispatch: # 允许手动触发</span><br><span class=\"line\"></span><br><span class=\"line\"># 为 GITHUB_TOKEN 设置默认权限，以便部署到 GitHub Pages</span><br><span class=\"line\">permissions:</span><br><span class=\"line\">  contents: read      # checkout 代码需要</span><br><span class=\"line\">  pages: write        # 部署到 GitHub Pages 需要</span><br><span class=\"line\">  id-token: write     # OIDC 认证需要 (actions/deploy-pages 使用)</span><br><span class=\"line\"></span><br><span class=\"line\"># 只允许一个并发部署，跳过在队列中等待的运行。</span><br><span class=\"line\"># 但是，不要取消进行中的运行，因为我们希望允许那些部署完成。</span><br><span class=\"line\">concurrency:</span><br><span class=\"line\">  group: &quot;pages&quot;</span><br><span class=\"line\">  cancel-in-progress: false</span><br><span class=\"line\"></span><br><span class=\"line\">jobs:</span><br><span class=\"line\">  build:</span><br><span class=\"line\">    runs-on: ubuntu-latest</span><br><span class=\"line\">    steps:</span><br><span class=\"line\">      - name: Checkout</span><br><span class=\"line\">        uses: actions/checkout@v4</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Setup Node.js</span><br><span class=\"line\">        uses: actions/setup-node@v4</span><br><span class=\"line\">        with:</span><br><span class=\"line\">          node-version: &quot;20&quot; # 或者你的项目使用的版本</span><br><span class=\"line\">          cache: &#x27;npm&#x27;</span><br><span class=\"line\">          cache-dependency-path: client/package-lock.json # 更精确的缓存路径</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Install Dependencies</span><br><span class=\"line\">        working-directory: ./client</span><br><span class=\"line\">        run: npm ci # 使用 ci 更稳定</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Build</span><br><span class=\"line\">        working-directory: ./client</span><br><span class=\"line\">        run: npm run build # 确保你的 vite.config.js 中 base: &#x27;/仓库名/&#x27; 已设置</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Setup Pages</span><br><span class=\"line\">        uses: actions/configure-pages@v4 # 官方action</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Upload artifact</span><br><span class=\"line\">        uses: actions/upload-pages-artifact@v3 # 官方action</span><br><span class=\"line\">        with:</span><br><span class=\"line\">          # 从 client/dist 目录上传</span><br><span class=\"line\">          path: &#x27;./client/dist&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">  deploy:</span><br><span class=\"line\">    needs: build # 依赖 build job</span><br><span class=\"line\">    runs-on: ubuntu-latest</span><br><span class=\"line\">    environment:</span><br><span class=\"line\">      name: github-pages</span><br><span class=\"line\">      url: $&#123;&#123; steps.deployment.outputs.page_url &#125;&#125; # 输出部署后的 URL</span><br><span class=\"line\">    steps:</span><br><span class=\"line\">      - name: Deploy to GitHub Pages</span><br><span class=\"line\">        id: deployment</span><br><span class=\"line\">        uses: actions/deploy-pages@v4 # 官方action</span><br></pre></td></tr></table></figure>\n\n<p>在本地进行git pull后，在client目录下的vite.config.js里面添加这行代码base:’&#x2F;{仓库名}&#x2F;‘,package.json里面添加这行代码”homepage”: “<a href=\"https://kkzyu.github.io/%7B%E4%BB%93%E5%BA%93%E5%90%8D%7D%22%E3%80%82\">https://kkzyu.github.io/{仓库名}&quot;。</a></p>\n<p>再到github的setting下进行以下操作：</p>\n<ul>\n<li>pages下的source选择github actions；</li>\n<li>environment下检查是否存在github-pages，点击进入查看是否有master这个分支；</li>\n<li>actions的general下，勾选read and write permission以及Allow GitHub Actions to create and approve pull requests。</li>\n</ul>\n<p>在部署last1km的时候出现了很多路径上的问题，导致信息无法正常显示，这主要是因为在vite中把base改成了&#x2F;last1km&#x2F;后在解析的时候路径发生了变化，这也是写代码的时候不太规范导致的问题。</p>\n<p>以chatpage.vue为例，下面是对应的解决办法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 定义baseurl为vite下记录的url</span><br><span class=\"line\">const BASE_URL = import.meta.env.BASE_URL;</span><br><span class=\"line\"># 由于在json文件里面保留了/对应的public路径，所以这里需要对路径格式进行修改，由于baseurl的last1km后面还跟着一个/，所以需要去掉其中的一个/</span><br><span class=\"line\">const resolveAssetPath = (relativePath) =&gt; &#123;</span><br><span class=\"line\">  if (!relativePath) return undefined;</span><br><span class=\"line\">  let path = relativePath;</span><br><span class=\"line\">  if (BASE_URL.endsWith(&#x27;/&#x27;) &amp;&amp; path.startsWith(&#x27;/&#x27;)) &#123;</span><br><span class=\"line\">    path = path.substring(1);</span><br><span class=\"line\">  &#125; else if (!BASE_URL.endsWith(&#x27;/&#x27;) &amp;&amp; !path.startsWith(&#x27;/&#x27;)) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return `$&#123;BASE_URL&#125;$&#123;path&#125;`;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"># 这个可以直接放到stores下用pinia管理，并导入</span><br><span class=\"line\"># ......</span><br><span class=\"line\"># 对应的在获取数据时也要进行以下更改</span><br><span class=\"line\">    const fetchPath = &#x27;data/messages.json&#x27;; // Path relative to public directory</span><br><span class=\"line\">    const response = await fetch(`$&#123;BASE_URL&#125;$&#123;fetchPath&#125;`);</span><br><span class=\"line\">    const riderData = currentChatData.rider ? &#123;</span><br><span class=\"line\">        ...currentChatData.rider,</span><br><span class=\"line\">        // chatInfo.rider.avatar 的值如 &quot;/images/avatar1.jpg&quot;</span><br><span class=\"line\">        // resolveAssetPath会处理它，变成 &quot;/last1km/images/avatar1.jpg&quot;</span><br><span class=\"line\">        avatar: currentChatData.rider.avatar ? resolveAssetPath(currentChatData.rider.avatar) : undefined</span><br><span class=\"line\">      &#125; : null;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"仓库迁移","date":"2025-04-29T03:00:26.000Z","_content":"## 仓库迁移与合并\n1. 先删除现有远程仓库\n```bash\ngit remote remove githu\n```\n2. 添加新仓库为远程仓库\n```bash\ngit remote add github git@github.com:kkzyu/kkzyu.github.io.git\n```\n3. 验证远程仓库\n```bash\ngit remote -v\n```\n4. 获取仓库2代码\n```bash\ngit fetch github\n```\n5. 合并代码（保留双方历史）\n```bash\ngit merge github/main --allow-unrelated-histories\n```\n6. 解决冲突（重点关注以下文件）\n- 用编辑器处理冲突的.gitignore、package.json等\n- 保留Gitee仓库的.gitignore规则\n\n7. 提交变更\n```bash\ngit add .\ngit commit -m \"迁移完成：包含仓库2源码及网址文件\"\ngit push origin main\n```\n8. 验证代码完整性\n```bash\nnpm install && npm run dev # 确保能正常启动开发服务器\n```","source":"_posts/仓库迁移.md","raw":"---\ntitle: 仓库迁移\ndate: 2025-04-29 11:00:26\ntags: [git, web前端]\n\n\n---\n## 仓库迁移与合并\n1. 先删除现有远程仓库\n```bash\ngit remote remove githu\n```\n2. 添加新仓库为远程仓库\n```bash\ngit remote add github git@github.com:kkzyu/kkzyu.github.io.git\n```\n3. 验证远程仓库\n```bash\ngit remote -v\n```\n4. 获取仓库2代码\n```bash\ngit fetch github\n```\n5. 合并代码（保留双方历史）\n```bash\ngit merge github/main --allow-unrelated-histories\n```\n6. 解决冲突（重点关注以下文件）\n- 用编辑器处理冲突的.gitignore、package.json等\n- 保留Gitee仓库的.gitignore规则\n\n7. 提交变更\n```bash\ngit add .\ngit commit -m \"迁移完成：包含仓库2源码及网址文件\"\ngit push origin main\n```\n8. 验证代码完整性\n```bash\nnpm install && npm run dev # 确保能正常启动开发服务器\n```","slug":"仓库迁移","published":1,"updated":"2025-07-08T01:44:29.143Z","comments":1,"layout":"post","photos":[],"_id":"cmd15y0wl000vlstv81qj0wg6","content":"<h2 id=\"仓库迁移与合并\"><a href=\"#仓库迁移与合并\" class=\"headerlink\" title=\"仓库迁移与合并\"></a>仓库迁移与合并</h2><ol>\n<li>先删除现有远程仓库<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote remove githu</span><br></pre></td></tr></table></figure></li>\n<li>添加新仓库为远程仓库<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add github git@github.com:kkzyu/kkzyu.github.io.git</span><br></pre></td></tr></table></figure></li>\n<li>验证远程仓库<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure></li>\n<li>获取仓库2代码<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch github</span><br></pre></td></tr></table></figure></li>\n<li>合并代码（保留双方历史）<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge github/main --allow-unrelated-histories</span><br></pre></td></tr></table></figure></li>\n<li>解决冲突（重点关注以下文件）</li>\n</ol>\n<ul>\n<li>用编辑器处理冲突的.gitignore、package.json等</li>\n<li>保留Gitee仓库的.gitignore规则</li>\n</ul>\n<ol start=\"7\">\n<li>提交变更<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;迁移完成：包含仓库2源码及网址文件&quot;</span></span><br><span class=\"line\">git push origin main</span><br></pre></td></tr></table></figure></li>\n<li>验证代码完整性<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install &amp;&amp; npm run dev <span class=\"comment\"># 确保能正常启动开发服务器</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n","length":395,"excerpt":"","more":"<h2 id=\"仓库迁移与合并\"><a href=\"#仓库迁移与合并\" class=\"headerlink\" title=\"仓库迁移与合并\"></a>仓库迁移与合并</h2><ol>\n<li>先删除现有远程仓库<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote remove githu</span><br></pre></td></tr></table></figure></li>\n<li>添加新仓库为远程仓库<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add github git@github.com:kkzyu/kkzyu.github.io.git</span><br></pre></td></tr></table></figure></li>\n<li>验证远程仓库<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure></li>\n<li>获取仓库2代码<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch github</span><br></pre></td></tr></table></figure></li>\n<li>合并代码（保留双方历史）<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge github/main --allow-unrelated-histories</span><br></pre></td></tr></table></figure></li>\n<li>解决冲突（重点关注以下文件）</li>\n</ol>\n<ul>\n<li>用编辑器处理冲突的.gitignore、package.json等</li>\n<li>保留Gitee仓库的.gitignore规则</li>\n</ul>\n<ol start=\"7\">\n<li>提交变更<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;迁移完成：包含仓库2源码及网址文件&quot;</span></span><br><span class=\"line\">git push origin main</span><br></pre></td></tr></table></figure></li>\n<li>验证代码完整性<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install &amp;&amp; npm run dev <span class=\"comment\"># 确保能正常启动开发服务器</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"layout":"posts","title":"week1-研发周报-作业管理详情页开发","date":"2025-07-12T12:05:52.000Z","_content":"\n## 研发周报 - 2025年7月12日\n\n本周我主要负责**作业管理详情**页面的开发与联调工作，并成功解决了开发过程中遇到的一系列技术挑战，确保了新功能的顺利推进和应用的整体稳定性。\n\n### 一、本周核心工作成果\n\n1.  **基本信息展示：** 完成了作业详情页面“基本信息”模块的开发，按照作业信息/应用信息/用户信息的分类清晰、完整地展示所有和作业管理有关的详情信息。\n    ![alt text](week1-研发周报-作业管理详情页开发-1.png)\n\n2.  **文档查看与下载**：实现了“作业文档”模块的开发，支持通过弹窗在线查看和批量下载作业相关文件，并特别优化了大文件的查看体验。\n\n### 二、关键技术问题攻坚与解决方案\n\n在开发过程中，我遇到并解决了一些具有代表性的技术难题，具体如下：\n\n1.  **优化大文件的查看体验：** 针由于作业文档中可能存在体积较大的文件，因此设置首次打开时仅加载部分内容以保证弹窗秒开，同时提供“加载更多”按钮，用户点击后可加载剩余全部内容，显著提升了用户体验和前端性能。\n\n2.  **组件拆分：** 为了增强代码的可读性，以及对页面性能进行进一步优化。我将整个页面拆分成了以下四个组件：\n    *   `BasicInfoCard`：展示组件，用于展示基础信息。接收一个名为 `data` 的 prop，根据 `data` 的内容渲染出描述列表。\n    *   `JobDetail`：基本信息的容器组件，用于处理逻辑和数据。负责从路由中获取 `jobId`，调用 API 来获取数据，管理状态，将数据传递给子组件 `BasicInfoCard`。\n    *   `DocumentTableCard`：用于获取文件列表/展示列表/搜索/批量下载。\n    *   `FileViewerModal`：用于专门负责文件内容的预览功能。\n\n> **为何将“基本信息”拆分成两个组件（一个用于加载数据一个用于展示），而对于“作业文档”则不拆分呢？**\n>\n> 因为我使用了 `Tabs` 这个组件来展示“基本信息”和“作业文档”时，`Tabs` 会“懒加载”它的面板内容。只有当用户点击“作业文档”时，对应的组件才会被渲染，去请求文件列表的 API。而如果遵循容器/展示组件的模式进行拆分的话，会失去懒加载带来的性能优化，即使用户不查看文件列表数据也会被立即获取，这样会浪费网络资源并增加服务器压力。\n\n### 三、下周工作计划\n\n继续完善【作业详情】页面的收尾工作，并与后端进行最终确认。","source":"_posts/week1-研发周报-作业管理详情页开发.md","raw":"---\nlayout: posts\ntitle: week1-研发周报-作业管理详情页开发\ndate: 2025-07-12 20:05:52\ntags: [web前端, 实习日记]\n---\n\n## 研发周报 - 2025年7月12日\n\n本周我主要负责**作业管理详情**页面的开发与联调工作，并成功解决了开发过程中遇到的一系列技术挑战，确保了新功能的顺利推进和应用的整体稳定性。\n\n### 一、本周核心工作成果\n\n1.  **基本信息展示：** 完成了作业详情页面“基本信息”模块的开发，按照作业信息/应用信息/用户信息的分类清晰、完整地展示所有和作业管理有关的详情信息。\n    ![alt text](week1-研发周报-作业管理详情页开发-1.png)\n\n2.  **文档查看与下载**：实现了“作业文档”模块的开发，支持通过弹窗在线查看和批量下载作业相关文件，并特别优化了大文件的查看体验。\n\n### 二、关键技术问题攻坚与解决方案\n\n在开发过程中，我遇到并解决了一些具有代表性的技术难题，具体如下：\n\n1.  **优化大文件的查看体验：** 针由于作业文档中可能存在体积较大的文件，因此设置首次打开时仅加载部分内容以保证弹窗秒开，同时提供“加载更多”按钮，用户点击后可加载剩余全部内容，显著提升了用户体验和前端性能。\n\n2.  **组件拆分：** 为了增强代码的可读性，以及对页面性能进行进一步优化。我将整个页面拆分成了以下四个组件：\n    *   `BasicInfoCard`：展示组件，用于展示基础信息。接收一个名为 `data` 的 prop，根据 `data` 的内容渲染出描述列表。\n    *   `JobDetail`：基本信息的容器组件，用于处理逻辑和数据。负责从路由中获取 `jobId`，调用 API 来获取数据，管理状态，将数据传递给子组件 `BasicInfoCard`。\n    *   `DocumentTableCard`：用于获取文件列表/展示列表/搜索/批量下载。\n    *   `FileViewerModal`：用于专门负责文件内容的预览功能。\n\n> **为何将“基本信息”拆分成两个组件（一个用于加载数据一个用于展示），而对于“作业文档”则不拆分呢？**\n>\n> 因为我使用了 `Tabs` 这个组件来展示“基本信息”和“作业文档”时，`Tabs` 会“懒加载”它的面板内容。只有当用户点击“作业文档”时，对应的组件才会被渲染，去请求文件列表的 API。而如果遵循容器/展示组件的模式进行拆分的话，会失去懒加载带来的性能优化，即使用户不查看文件列表数据也会被立即获取，这样会浪费网络资源并增加服务器压力。\n\n### 三、下周工作计划\n\n继续完善【作业详情】页面的收尾工作，并与后端进行最终确认。","slug":"week1-研发周报-作业管理详情页开发","published":1,"updated":"2025-07-12T13:24:30.579Z","comments":1,"photos":[],"_id":"cmd15y0wm000xlstv8t201lbi","content":"<h2 id=\"研发周报-2025年7月12日\"><a href=\"#研发周报-2025年7月12日\" class=\"headerlink\" title=\"研发周报 - 2025年7月12日\"></a>研发周报 - 2025年7月12日</h2><p>本周我主要负责<strong>作业管理详情</strong>页面的开发与联调工作，并成功解决了开发过程中遇到的一系列技术挑战，确保了新功能的顺利推进和应用的整体稳定性。</p>\n<h3 id=\"一、本周核心工作成果\"><a href=\"#一、本周核心工作成果\" class=\"headerlink\" title=\"一、本周核心工作成果\"></a>一、本周核心工作成果</h3><ol>\n<li><p><strong>基本信息展示：</strong> 完成了作业详情页面“基本信息”模块的开发，按照作业信息&#x2F;应用信息&#x2F;用户信息的分类清晰、完整地展示所有和作业管理有关的详情信息。<br><img src=\"/blog/week1-%E7%A0%94%E5%8F%91%E5%91%A8%E6%8A%A5-%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86%E8%AF%A6%E6%83%85%E9%A1%B5%E5%BC%80%E5%8F%91-1.png\" alt=\"alt text\"></p>\n</li>\n<li><p><strong>文档查看与下载</strong>：实现了“作业文档”模块的开发，支持通过弹窗在线查看和批量下载作业相关文件，并特别优化了大文件的查看体验。</p>\n</li>\n</ol>\n<h3 id=\"二、关键技术问题攻坚与解决方案\"><a href=\"#二、关键技术问题攻坚与解决方案\" class=\"headerlink\" title=\"二、关键技术问题攻坚与解决方案\"></a>二、关键技术问题攻坚与解决方案</h3><p>在开发过程中，我遇到并解决了一些具有代表性的技术难题，具体如下：</p>\n<ol>\n<li><p><strong>优化大文件的查看体验：</strong> 针由于作业文档中可能存在体积较大的文件，因此设置首次打开时仅加载部分内容以保证弹窗秒开，同时提供“加载更多”按钮，用户点击后可加载剩余全部内容，显著提升了用户体验和前端性能。</p>\n</li>\n<li><p><strong>组件拆分：</strong> 为了增强代码的可读性，以及对页面性能进行进一步优化。我将整个页面拆分成了以下四个组件：</p>\n<ul>\n<li><code>BasicInfoCard</code>：展示组件，用于展示基础信息。接收一个名为 <code>data</code> 的 prop，根据 <code>data</code> 的内容渲染出描述列表。</li>\n<li><code>JobDetail</code>：基本信息的容器组件，用于处理逻辑和数据。负责从路由中获取 <code>jobId</code>，调用 API 来获取数据，管理状态，将数据传递给子组件 <code>BasicInfoCard</code>。</li>\n<li><code>DocumentTableCard</code>：用于获取文件列表&#x2F;展示列表&#x2F;搜索&#x2F;批量下载。</li>\n<li><code>FileViewerModal</code>：用于专门负责文件内容的预览功能。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p><strong>为何将“基本信息”拆分成两个组件（一个用于加载数据一个用于展示），而对于“作业文档”则不拆分呢？</strong></p>\n<p>因为我使用了 <code>Tabs</code> 这个组件来展示“基本信息”和“作业文档”时，<code>Tabs</code> 会“懒加载”它的面板内容。只有当用户点击“作业文档”时，对应的组件才会被渲染，去请求文件列表的 API。而如果遵循容器&#x2F;展示组件的模式进行拆分的话，会失去懒加载带来的性能优化，即使用户不查看文件列表数据也会被立即获取，这样会浪费网络资源并增加服务器压力。</p>\n</blockquote>\n<h3 id=\"三、下周工作计划\"><a href=\"#三、下周工作计划\" class=\"headerlink\" title=\"三、下周工作计划\"></a>三、下周工作计划</h3><p>继续完善【作业详情】页面的收尾工作，并与后端进行最终确认。</p>\n","length":908,"excerpt":"","more":"<h2 id=\"研发周报-2025年7月12日\"><a href=\"#研发周报-2025年7月12日\" class=\"headerlink\" title=\"研发周报 - 2025年7月12日\"></a>研发周报 - 2025年7月12日</h2><p>本周我主要负责<strong>作业管理详情</strong>页面的开发与联调工作，并成功解决了开发过程中遇到的一系列技术挑战，确保了新功能的顺利推进和应用的整体稳定性。</p>\n<h3 id=\"一、本周核心工作成果\"><a href=\"#一、本周核心工作成果\" class=\"headerlink\" title=\"一、本周核心工作成果\"></a>一、本周核心工作成果</h3><ol>\n<li><p><strong>基本信息展示：</strong> 完成了作业详情页面“基本信息”模块的开发，按照作业信息&#x2F;应用信息&#x2F;用户信息的分类清晰、完整地展示所有和作业管理有关的详情信息。<br><img src=\"/blog/week1-%E7%A0%94%E5%8F%91%E5%91%A8%E6%8A%A5-%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86%E8%AF%A6%E6%83%85%E9%A1%B5%E5%BC%80%E5%8F%91-1.png\" alt=\"alt text\"></p>\n</li>\n<li><p><strong>文档查看与下载</strong>：实现了“作业文档”模块的开发，支持通过弹窗在线查看和批量下载作业相关文件，并特别优化了大文件的查看体验。</p>\n</li>\n</ol>\n<h3 id=\"二、关键技术问题攻坚与解决方案\"><a href=\"#二、关键技术问题攻坚与解决方案\" class=\"headerlink\" title=\"二、关键技术问题攻坚与解决方案\"></a>二、关键技术问题攻坚与解决方案</h3><p>在开发过程中，我遇到并解决了一些具有代表性的技术难题，具体如下：</p>\n<ol>\n<li><p><strong>优化大文件的查看体验：</strong> 针由于作业文档中可能存在体积较大的文件，因此设置首次打开时仅加载部分内容以保证弹窗秒开，同时提供“加载更多”按钮，用户点击后可加载剩余全部内容，显著提升了用户体验和前端性能。</p>\n</li>\n<li><p><strong>组件拆分：</strong> 为了增强代码的可读性，以及对页面性能进行进一步优化。我将整个页面拆分成了以下四个组件：</p>\n<ul>\n<li><code>BasicInfoCard</code>：展示组件，用于展示基础信息。接收一个名为 <code>data</code> 的 prop，根据 <code>data</code> 的内容渲染出描述列表。</li>\n<li><code>JobDetail</code>：基本信息的容器组件，用于处理逻辑和数据。负责从路由中获取 <code>jobId</code>，调用 API 来获取数据，管理状态，将数据传递给子组件 <code>BasicInfoCard</code>。</li>\n<li><code>DocumentTableCard</code>：用于获取文件列表&#x2F;展示列表&#x2F;搜索&#x2F;批量下载。</li>\n<li><code>FileViewerModal</code>：用于专门负责文件内容的预览功能。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p><strong>为何将“基本信息”拆分成两个组件（一个用于加载数据一个用于展示），而对于“作业文档”则不拆分呢？</strong></p>\n<p>因为我使用了 <code>Tabs</code> 这个组件来展示“基本信息”和“作业文档”时，<code>Tabs</code> 会“懒加载”它的面板内容。只有当用户点击“作业文档”时，对应的组件才会被渲染，去请求文件列表的 API。而如果遵循容器&#x2F;展示组件的模式进行拆分的话，会失去懒加载带来的性能优化，即使用户不查看文件列表数据也会被立即获取，这样会浪费网络资源并增加服务器压力。</p>\n</blockquote>\n<h3 id=\"三、下周工作计划\"><a href=\"#三、下周工作计划\" class=\"headerlink\" title=\"三、下周工作计划\"></a>三、下周工作计划</h3><p>继续完善【作业详情】页面的收尾工作，并与后端进行最终确认。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cmd15y0w60001lstv1jgxc04l","tag_id":"cmd15y0w90003lstv7srbaahk","_id":"cmd15y0we0009lstv7kjy7ouf"},{"post_id":"cmd15y0w60001lstv1jgxc04l","tag_id":"cmd15y0wc0007lstvct7ea6wk","_id":"cmd15y0wf000alstv41ce6ysq"},{"post_id":"cmd15y0w80002lstv2uk61qsf","tag_id":"cmd15y0wd0008lstval3aeufn","_id":"cmd15y0wh000elstvdu08am53"},{"post_id":"cmd15y0w80002lstv2uk61qsf","tag_id":"cmd15y0wf000blstvgjsi63no","_id":"cmd15y0wh000flstvh7jrglwr"},{"post_id":"cmd15y0w80002lstv2uk61qsf","tag_id":"cmd15y0wf000clstvhjd48iun","_id":"cmd15y0wh000hlstvfchhfsj0"},{"post_id":"cmd15y0wb0004lstv7ouu401j","tag_id":"cmd15y0w90003lstv7srbaahk","_id":"cmd15y0wh000jlstv1efv8m1s"},{"post_id":"cmd15y0wb0004lstv7ouu401j","tag_id":"cmd15y0wc0007lstvct7ea6wk","_id":"cmd15y0wh000klstv0yhi10fo"},{"post_id":"cmd15y0wb0005lstvfnn46jmb","tag_id":"cmd15y0wd0008lstval3aeufn","_id":"cmd15y0wi000olstvellz6jbh"},{"post_id":"cmd15y0wb0005lstvfnn46jmb","tag_id":"cmd15y0wf000blstvgjsi63no","_id":"cmd15y0wi000plstvfk1r5ebq"},{"post_id":"cmd15y0wb0005lstvfnn46jmb","tag_id":"cmd15y0wf000clstvhjd48iun","_id":"cmd15y0wi000qlstv4hvj6qf4"},{"post_id":"cmd15y0wc0006lstv4mfk905s","tag_id":"cmd15y0wf000blstvgjsi63no","_id":"cmd15y0wi000rlstv094j037n"},{"post_id":"cmd15y0wk000slstv7lbmar7v","tag_id":"cmd15y0wf000blstvgjsi63no","_id":"cmd15y0wl000ulstve52zfwa0"},{"post_id":"cmd15y0wm000xlstv8t201lbi","tag_id":"cmd15y0wf000blstvgjsi63no","_id":"cmd15y0wn000ylstv66hv6sl2"},{"post_id":"cmd15y0wm000xlstv8t201lbi","tag_id":"cmd15y0wf000clstvhjd48iun","_id":"cmd15y0wo0010lstv7xts71x2"},{"post_id":"cmd15y0wk000tlstv1rnh9n81","tag_id":"cmd15y0wm000wlstvfce0960e","_id":"cmd15y0wo0011lstv9baa4qpr"},{"post_id":"cmd15y0wk000tlstv1rnh9n81","tag_id":"cmd15y0wf000blstvgjsi63no","_id":"cmd15y0wo0012lstvbn0xdzp8"},{"post_id":"cmd15y0wl000vlstv81qj0wg6","tag_id":"cmd15y0wm000wlstvfce0960e","_id":"cmd15y0wo0013lstvefcf8bv8"},{"post_id":"cmd15y0wl000vlstv81qj0wg6","tag_id":"cmd15y0wf000blstvgjsi63no","_id":"cmd15y0wo0014lstvezk77xib"}],"Tag":[{"name":"深度学习","_id":"cmd15y0w90003lstv7srbaahk"},{"name":"AI医学","_id":"cmd15y0wc0007lstvct7ea6wk"},{"name":"react","_id":"cmd15y0wd0008lstval3aeufn"},{"name":"web前端","_id":"cmd15y0wf000blstvgjsi63no"},{"name":"实习日记","_id":"cmd15y0wf000clstvhjd48iun"},{"name":"git","_id":"cmd15y0wm000wlstvfce0960e"}]}}